# Streamlit STIX 2.1 Visualizer and Editor
# -----------------------------------------
# Requirements:
#   pip install streamlit stix2 st-cytoscape python-dateutil
#
# Run: python -m streamlit run your_script_name.py

import streamlit as st
# Ensure necessary STIX classes are imported (or rely on generic parsing)
from stix2 import (Bundle, parse, AttackPattern, Campaign, CourseOfAction, Identity,
                   Indicator, Infrastructure, IntrusionSet, Location, Malware, Note,
                   ObservedData, Report, ThreatActor, Tool, Vulnerability)
from stix2.exceptions import InvalidValueError
import uuid
import json
from st_cytoscape import cytoscape
import base64
import os
import re
import io
import time # Only for minor delays in status updates
from datetime import datetime, time as dt_time, date, timezone # Import timezone
from dateutil.parser import isoparse
import urllib.parse

# --- Configuration ---
st.set_page_config(page_title="Stixer by Manb4t", layout="wide")

# --- Vocabularies & Mappings (Define BEFORE Session State) ---

# Hardcoded Relationship Rules (Keep as is)
HARDCODED_VALID_RELATIONSHIPS = {
    ('attack-pattern', 'malware'): ['delivers', 'uses'], ('attack-pattern', 'identity'): ['targets'],
    ('attack-pattern', 'location'): ['targets'], ('attack-pattern', 'vulnerability'): ['targets'],
    ('attack-pattern', 'tool'): ['uses'], ('campaign', 'intrusion-set'): ['attributed-to'],
    ('campaign', 'threat-actor'): ['attributed-to'], ('campaign', 'infrastructure'): ['compromises', 'uses'],
    ('campaign', 'location'): ['originates-from', 'targets'], ('campaign', 'identity'): ['targets'],
    ('campaign', 'vulnerability'): ['targets'], ('campaign', 'attack-pattern'): ['uses'],
    ('campaign', 'malware'): ['uses'], ('course-of-action', 'indicator'): ['investigates', 'mitigates'],
    ('course-of-action', 'attack-pattern'): ['mitigates'], ('course-of-action', 'malware'): ['mitigates'],
    ('course-of-action', 'tool'): ['mitigates'], ('course-of-action', 'vulnerability'): ['mitigates'],
    ('identity', 'location'): ['located-at'], ('indicator', 'attack-pattern'): ['indicates'],
    ('indicator', 'campaign'): ['indicates'], ('indicator', 'infrastructure'): ['indicates'],
    ('indicator', 'intrusion-set'): ['indicates'], ('indicator', 'malware'): ['indicates'],
    ('indicator', 'threat-actor'): ['indicates'], ('indicator', 'tool'): ['indicates'],
    ('indicator', 'observed-data'): ['based-on'],
    ('infrastructure', 'infrastructure'): ['communicates-with', 'consists-of', 'controls', 'uses'],
    ('infrastructure', 'ipv4-addr'): ['communicates-with'], ('infrastructure', 'ipv6-addr'): ['communicates-with'],
    ('infrastructure', 'domain-name'): ['communicates-with'], ('infrastructure', 'url'): ['communicates-with'],
    ('infrastructure', 'observed-data'): ['consists-of'], ('infrastructure', 'malware'): ['controls', 'delivers', 'hosts'],
    ('infrastructure', 'vulnerability'): ['has'], ('infrastructure', 'tool'): ['hosts'],
    ('infrastructure', 'location'): ['located-at'], ('intrusion-set', 'threat-actor'): ['attributed-to'],
    ('intrusion-set', 'infrastructure'): ['compromises', 'hosts', 'owns', 'uses'],
    ('intrusion-set', 'location'): ['originates-from', 'targets'], ('intrusion-set', 'vulnerability'): ['targets'],
    ('intrusion-set', 'identity'): ['targets'], ('intrusion-set', 'attack-pattern'): ['uses'],
    ('intrusion-set', 'malware'): ['uses'], ('intrusion-set', 'tool'): ['uses'],
    ('malware', 'threat-actor'): ['authored-by'], ('malware', 'intrusion-set'): ['authored-by'],
    ('malware', 'infrastructure'): ['beacons-to', 'exfiltrate-to', 'targets', 'uses'],
    ('malware', 'url'): ['communicates-with'], ('malware', 'domain-name'): ['communicates-with'],
    ('malware', 'ipv6-addr'): ['communicates-with'], ('malware', 'ipv4-addr'): ['communicates-with'],
    ('malware', 'malware'): ['controls', 'downloads', 'drops', 'uses', 'variant-of'],
    ('malware', 'tool'): ['downloads', 'drops', 'uses'], ('malware', 'file'): ['downloads', 'drops'],
    ('malware', 'vulnerability'): ['exploits', 'targets'], ('malware', 'location'): ['originates-from', 'targets'],
    ('malware', 'identity'): ['targets'], ('malware', 'attack-pattern'): ['uses'],
    ('malware-analysis', 'malware'): ['characterizes', 'analysis-of', 'static-analysis-of', 'dynamic-analysis-of'],
    ('threat-actor', 'identity'): ['attributed-to', 'impersonates', 'targets'],
    ('threat-actor', 'infrastructure'): ['compromises', 'owns', 'hosts', 'uses'],
    ('threat-actor', 'location'): ['located-at', 'targets'], ('threat-actor', 'vulnerability'): ['targets'],
    ('threat-actor', 'attack-pattern'): ['uses'], ('threat-actor', 'malware'): ['uses'],
    ('threat-actor', 'tool'): ['uses'], ('tool', 'malware'): ['delivers', 'drops'],
    ('tool', 'vulnerability'): ['has', 'targets'], ('tool', 'identity'): ['targets'],
    ('tool', 'infrastructure'): ['targets'], ('tool', 'location'): ['targets'],
    ('domain-name', 'domain-name'): ['resolves-to'],
    ('domain-name', 'ipv4-addr'): ['resolves-to'],
    ('domain-name', 'ipv6-addr'): ['resolves-to'],
}

# Vocabularies (Keep as is)
THREAT_ACTOR_TYPES_OV = ["", "activist", "competitor", "crime-syndicate", "criminal", "hacker", "insider-accidental", "insider-disgruntled", "nation-state", "sensationalist", "spy", "terrorist", "unknown"]
THREAT_ACTOR_ROLES_OV = ["", "agent", "director", "independent", "infrastructure-architect", "infrastructure-operator", "malware-author", "sponsor"]
THREAT_ACTOR_SOPHISTICATION_OV = ["", "none", "minimal", "intermediate", "advanced", "expert", "innovator", "strategic"]
ATTACK_RESOURCE_LEVEL_OV = ["", "individual", "club", "contest", "team", "organization", "government"]
ATTACK_MOTIVATION_OV = ["", "accidental", "coercion", "dominance", "ideology", "notoriety", "organizational-gain", "personal-gain", "personal-satisfaction", "revenge", "unpredictable"]
HASH_ALGO_OV = ["", "MD5", "SHA-1", "SHA-256", "SHA-512", "SHA3-256", "SHA3-512", "SSDEEP", "TLSH"]
IDENTITY_CLASS_OV = ["", "individual", "group", "system", "organization", "class", "unknown"]
INDICATOR_TYPES_OV = ["", "anomalous-activity", "anonymization", "benign", "compromised", "malicious-activity", "attribution", "unknown"]
MALWARE_TYPES_OV = ["", "adware", "backdoor", "bot", "bootkit", "ddos", "downloader", "dropper", "exploit-kit", "keylogger", "ransomware", "remote-access-trojan", "resource-exploitation", "rootkit", "screen-capture", "spyware", "trojan", "unknown", "virus", "webshell", "wiper", "worm"]
REPORT_TYPES_OV = ["", "attack-pattern", "campaign", "identity", "indicator", "intrusion-set", "malware", "observed-data", "threat-actor", "threat-report", "tool", "vulnerability"]
TOOL_TYPES_OV = ["", "denial-of-service", "exploitation", "information-gathering", "network-capture", "penetration-testing", "remote-access", "vulnerability-scanning", "unknown"]
REGION_OV = ["", "africa", "eastern-africa", "middle-africa", "northern-africa", "southern-africa", "western-africa", "americas", "latin-america-caribbean", "south-america", "caribbean", "central-america", "northern-america", "asia", "central-asia", "eastern-asia", "southern-asia", "south-eastern-asia", "western-asia", "europe", "eastern-europe", "northern-europe", "southern-europe", "western-europe", "oceania", "antarctica", "australia-new-zealand", "melanesia", "micronesia", "polynesia"]
INDUSTRY_SECTOR_OV = ["", "agriculture", "aerospace", "automotive", "communications", "construction", "defence", "education", "energy", "entertainment", "financial-services", "government-national", "government-regional", "government-local", "government-public-services", "healthcare", "hospitality-leisure", "infrastructure", "insurance", "manufacturing", "mining", "non-profit", "pharmaceuticals", "retail", "technology", "telecommunications", "transportation", "utilities"]
LOCKHEED_MARTIN_PHASES_STR = "Reconnaissance, Weaponization, Delivery, Exploitation, Installation, Command and Control (C2), Actions on Objectives"
KILL_CHAIN_NAMES = ["", "lockheed-martin-cyber-kill-chain", "mitre-attack", "unified-kill-chain", "custom"]
KILL_CHAIN_PHASES = {
    "lockheed-martin-cyber-kill-chain": ["reconnaissance", "weaponization", "delivery", "exploitation", "installation", "command-and-control", "actions-on-objectives"],
    "mitre-attack": ["reconnaissance", "resource-development", "initial-access", "execution", "persistence", "privilege-escalation", "defense-evasion", "credential-access", "discovery", "lateral-movement", "collection", "command-and-control", "exfiltration", "impact"],
    "unified-kill-chain": ["in", "through", "out"]
}
INFRASTRUCTURE_TYPES_OV = ["", "amplification", "anonymization", "botnet", "command-and-control", "exfiltration", "hosting-malware", "hosting-target-lists", "phishing", "reconnaissance", "staging", "unknown"]
PATTERN_TYPES_OV = ["stix", "pcre", "sigma", "snort", "suricata", "yara"] # For Indicator

# Define Object Types List (Add software)
source_types = set(k[0] for k in HARDCODED_VALID_RELATIONSHIPS.keys())
target_types = set(k[1] for k in HARDCODED_VALID_RELATIONSHIPS.keys())
hardcoded_types = source_types.union(target_types)
standard_types = [
    'attack-pattern','campaign','course-of-action','identity',
    'indicator','infrastructure','intrusion-set','malware','malware-analysis',
    'observed-data','report','threat-actor','tool','vulnerability',
    'location','note','marking-definition', 'language-content',
    'directory', 'domain-name', 'email-addr', 'email-message', 'file',
    'ipv4-addr', 'ipv6-addr', 'mac-addr', 'mutex', 'network-traffic',
    'process', 'software', 'url', 'user-account', 'windows-registry-key', # Added software
    'x509-certificate'
]
ALL_OBJECT_TYPES = sorted(list(set(standard_types).union(hardcoded_types)))

# Map STIX types to their respective classes (SCOs handled via dict)
TYPE_TO_CLASS_MAPPING = {
    'attack-pattern': AttackPattern, 'campaign': Campaign, 'course-of-action': CourseOfAction,
    'identity': Identity, 'indicator': Indicator, 'infrastructure': Infrastructure,
    'intrusion-set': IntrusionSet, 'location': Location, 'malware': Malware, 'note': Note,
    'observed-data': ObservedData, 'report': Report, 'threat-actor': ThreatActor,
    'tool': Tool, 'vulnerability': Vulnerability
    # SCOs like x509-certificate, domain-name, software will use generic parsing with allow_custom=True
}

# --- Session State Initialization ---
if 'objects' not in st.session_state: st.session_state.objects = []
if 'nodes' not in st.session_state: st.session_state.nodes = []
if 'edges' not in st.session_state: st.session_state.edges = []
if 'current_selection' not in st.session_state: st.session_state.current_selection = None
if 'rel_source_sel' not in st.session_state: st.session_state.rel_source_sel = None
if 'rel_target_sel' not in st.session_state: st.session_state.rel_target_sel = None
if 'add_form_selected_type' not in st.session_state:
    st.session_state.add_form_selected_type = ALL_OBJECT_TYPES[0] if ALL_OBJECT_TYPES else None
if 'uploaded_file_state' not in st.session_state: st.session_state.uploaded_file_state = None
if 'fullscreen_mode' not in st.session_state: st.session_state.fullscreen_mode = False
if 'editing_object_id' not in st.session_state: st.session_state.editing_object_id = None
if 'editing_relationship_id' not in st.session_state: st.session_state.editing_relationship_id = None
# State to store generated map URL to display after form submission
if 'map_url_to_display' not in st.session_state: st.session_state.map_url_to_display = None


# --- Styling (Simplified - Light Theme Only) ---
# (Keep existing styles)
st.markdown("""
<style>
/* Basic Light Theme Styles */
body { background-color: #f0f0f0; color: #0e1117; }
.stApp { background-color: #f0f0f0; }
.block-container { padding: 1rem 2rem; }
.sidebar .sidebar-content { background-color: #f0f0f0; }
.stTextArea textarea { font-family: monospace; height: 100px; }
.stCytoscape > div { width: 100%; height: 100%; border: 1px solid #cccccc; border-radius: 5px; background-color: #ffffff; }
.selected-node-main { border: 1px solid #cccccc; border-radius: 4px; padding: 8px; margin-bottom: 8px; background-color: #f8f9fa; font-size: 0.9em; word-wrap: break-word; color: #0e1117; }
.selected-node-label-main { font-weight: bold; color: #555; margin-right: 5px; }
.streamlit-expanderHeader { font-size: 1.0em; color: #0e1117; padding-top: 3px; padding-bottom: 3px; }
.streamlit-expander { border: 1px solid #cccccc; border-radius: 5px; background-color: #ffffff; }
.edit-form-container { border: 1px solid #007bff; border-radius: 5px; padding: 15px; margin-top: 5px; background-color: #e7f3ff; }
.edit-form-container .stButton button { background-color: #28a745; color: white; border-color: #28a745; }
.edit-form-container .stButton button:hover { background-color: #218838; border-color: #1e7e34; color: white; }
.edit-rel-form-container { border: 1px solid #ffc107; border-radius: 5px; padding: 15px; margin-top: 5px; background-color: #fff8e1; }
.edit-rel-form-container .stButton button { background-color: #ffc107; color: #212529; border-color: #ffc107; }
.edit-rel-form-container .stButton button:hover { background-color: #e0a800; border-color: #d39e00; color: #212529; }
.stForm h3 { margin-top: 1rem; margin-bottom: 0.5rem; color: #0e1117; }
.stForm [data-testid="column"] { padding-left: 5px; padding-right: 5px; }
.maps-link-container { margin-top: 10px; padding: 10px; background-color: #e9ecef; border: 1px dashed #cccccc; border-radius: 5px; }
.maps-link-container a { color: #007bff; }
.graph-header { margin-bottom: 0.5rem; }
.graph-header h4 { margin-bottom: 0; margin-top: 0; padding-bottom: 0; font-size: 1.2em; color: #0e1117; }
.graph-header .stButton > button { padding-top: 0.25rem; padding-bottom: 0.25rem; font-size: 0.8em; }
/* General Widget Styling */
.stTextInput > div > div > input, .stTextArea > div > div > textarea, .stSelectbox > div > div > div, .stMultiselect > div > div > div, .stDateInput > div > div > div, .stTimeInput > div > div > div, .stNumberInput > div > div > input { background-color: #ffffff; color: #0e1117; border: 1px solid #ced4da; border-radius: 5px; }
div[data-baseweb="popover"] ul { background-color: #ffffff; }
div[data-baseweb="popover"] ul li { color: #0e1117; }
div[data-baseweb="popover"] ul li:hover { background-color: #007bff; color: #ffffff; }
.stButton > button, .stDownloadButton > button { border: 1px solid #007bff; background-color: #007bff; color: #ffffff; border-radius: 5px; }
.stButton > button:hover, .stDownloadButton > button:hover { border: 1px solid #0056b3; background-color: #0056b3; color: #ffffff; }

/* Style the Streamlit header bar */
[data-testid="stHeader"] {
    background-color: #f0f0f0 !important; /* Match sidebar background, !important might be needed */
    border-bottom: 1px solid #cccccc; /* Add a subtle border */
}
/* Adjust main content padding if header looks too close */
/* section.main .block-container {
    padding-top: 5rem;
} */

</style>
""", unsafe_allow_html=True)


# --- Helper Functions ---

def get_object_type_from_id(stix_id):
    """Extracts the object type from a STIX ID."""
    if isinstance(stix_id, str) and '--' in stix_id:
        return stix_id.split('--')[0]
    return None

def remove_element(element_id):
    """Removes an element and its connected relationships from session state."""
    original_obj_count = len(st.session_state.objects)
    obj_to_remove = next((o for o in st.session_state.objects if o['id'] == element_id), None)
    if not obj_to_remove: return
    rels_to_remove_ids = set()
    if obj_to_remove['type'] == 'relationship':
        rels_to_remove_ids.add(element_id)
        st.session_state.edges = [e for e in st.session_state.edges if e['data']['id'] != element_id]
    else:
        connected_rels = [o['id'] for o in st.session_state.objects
                          if o.get('type') == 'relationship' and
                             (o.get('source_ref') == element_id or o.get('target_ref') == element_id)]
        rels_to_remove_ids.update(connected_rels)
        st.session_state.nodes = [n for n in st.session_state.nodes if n['data']['id'] != element_id]
        st.session_state.edges = [e for e in st.session_state.edges if e['data']['id'] not in rels_to_remove_ids]
    st.session_state.objects = [o for o in st.session_state.objects if o['id'] != element_id]
    if obj_to_remove['type'] != 'relationship' and rels_to_remove_ids:
         st.session_state.objects = [o for o in st.session_state.objects if o['id'] not in rels_to_remove_ids]

@st.cache_data
def get_icon_data_uri(obj_type):
    """Loads icon file, encodes it, and returns a data URI string."""
    try: script_dir = os.path.dirname(__file__)
    except NameError: script_dir = os.getcwd()
    icon_file = os.path.join(script_dir, 'icons', f"{obj_type}-round-flat-300-dpi.png")
    fallback_icon_file = os.path.join(script_dir, 'icons', "unknown-round-flat-300-dpi.png")
    icon_to_load = icon_file if os.path.exists(icon_file) else fallback_icon_file
    if not os.path.exists(icon_to_load): return None
    try:
        with open(icon_to_load, 'rb') as img_f: img_bytes = img_f.read()
        b64 = base64.b64encode(img_bytes).decode('utf-8')
        return f"url('data:image/png;base64,{b64}')"
    except Exception as e: print(f"Error reading icon file {icon_to_load}: {e}"); return None

# --- Form Generation and Parsing Helpers ---

def _get_default(data, key, default=""):
    val = data.get(key, default)
    return val if val is not None else default

def _list_to_text(data, key):
    return "\n".join(data.get(key, []))

def _kill_chain_to_text(data, key):
    phases = data.get(key, [])
    return "\n".join([f"{p.get('kill_chain_name', '')}:{p.get('phase_name', '')}" for p in phases])

def _hashes_to_text(hashes_dict):
    """Converts a hashes dictionary to a multiline string."""
    if not hashes_dict or not isinstance(hashes_dict, dict): return ""
    return "\n".join([f"{algo}:{h}" for algo, h in hashes_dict.items()])

def _ext_ref_hashes_to_text(ext_refs):
    if not ext_refs or not isinstance(ext_refs, list) or not ext_refs[0].get("hashes"): return ""
    hashes_dict = ext_refs[0].get("hashes", {})
    return "\n".join([f"{algo}:{h}" for algo, h in hashes_dict.items()])

def _parse_stix_timestamp(timestamp_str):
    if not timestamp_str or not isinstance(timestamp_str, str): return None, None
    try:
        dt_obj = isoparse(timestamp_str)
        if dt_obj.tzinfo is None: dt_obj = dt_obj.replace(tzinfo=timezone.utc)
        else: dt_obj = dt_obj.astimezone(timezone.utc)
        return dt_obj.date(), dt_obj.time().replace(tzinfo=None)
    except ValueError: return None, None

def generate_maps_link(lat, lon):
    """Generates a Google Maps link from latitude and longitude."""
    try:
        lat_f = float(lat); lon_f = float(lon)
        return f"https://www.google.com/maps/search/?api=1&query={lat_f},{lon_f}"
    except (ValueError, TypeError, AttributeError): return None

def generate_object_form_fields(obj_type, obj_data=None, key_prefix="add"):
    """Generates Streamlit form widgets for a given STIX object type."""
    data = obj_data or {}
    form_values = {}
    # --- Handle objects without 'name' or 'description' ---
    if obj_type in ['x509-certificate', 'domain-name', 'note', 'software']: # Added software
        display_label = _get_default(data, 'value', _get_default(data, 'serial_number', _get_default(data, 'subject', _get_default(data, 'abstract', _get_default(data, 'name', f"New {obj_type}"))))) # Software uses 'name'
        st.markdown(f"**{obj_type.replace('-', ' ').title()}:** {display_label}")
        # Software has name/desc, but let's handle it below
        if obj_type not in ['software']: # Don't show generic name/desc for cert, domain, note
            pass
        else: # Show name/desc for Software
            form_values['name'] = st.text_input("Name (Required)", value=_get_default(data, 'name'), key=f"{key_prefix}_{obj_type}_name")
            form_values['description'] = st.text_area("Description", value=_get_default(data, 'description'), key=f"{key_prefix}_{obj_type}_desc")
    else: # SDOs that typically have name/description
        name_required = obj_type in ['intrusion-set', 'threat-actor', 'malware', 'tool', 'vulnerability', 'campaign', 'identity', 'location', 'course-of-action', 'attack-pattern', 'report']
        name_label = "Name (Required)" if name_required else "Name / Value"
        form_values['name'] = st.text_input(name_label, value=_get_default(data, 'name'), key=f"{key_prefix}_{obj_type}_name")
        form_values['description'] = st.text_area("Description", value=_get_default(data, 'description'), key=f"{key_prefix}_{obj_type}_desc")

    st.subheader(f"{obj_type.replace('-', ' ').title()} Properties")

    def datetime_input(label, data_key, required=False):
        st.markdown(f"**{label}{' (Required)' if required else ''}**")
        default_date, default_time = _parse_stix_timestamp(data.get(data_key))
        col1, col2 = st.columns(2)
        with col1: form_values[f'{data_key}_date'] = st.date_input("Date", value=default_date, key=f"{key_prefix}_{data_key}_date")
        with col2: form_values[f'{data_key}_time'] = st.time_input("Time (UTC)", value=default_time or dt_time(0, 0), key=f"{key_prefix}_{data_key}_time", step=3600)

    def kill_chain_input(data_key_prefix):
        # (Keep existing kill chain logic)
        st.markdown("**Kill Chain Phase (Optional - Select One)**")
        kc_name_widget_key = f"{key_prefix}_{data_key_prefix}_kc_name_widget"
        custom_kc_name_widget_key = f"{key_prefix}_{data_key_prefix}_custom_kc_name_input"
        custom_phase_name_widget_key = f"{key_prefix}_{data_key_prefix}_custom_phase_name_input"
        phase_name_select_key = f"{key_prefix}_{data_key_prefix}_phase_name_select"
        default_kc_name = ""; default_phase_name = ""; is_custom_default = False
        if data.get('kill_chain_phases') and isinstance(data['kill_chain_phases'], list) and data['kill_chain_phases']:
            first_phase = data['kill_chain_phases'][0]
            default_kc_name = first_phase.get('kill_chain_name', "")
            default_phase_name = first_phase.get('phase_name', "")
            if default_kc_name not in KILL_CHAIN_NAMES: is_custom_default = True
            elif not default_kc_name: default_kc_name = ""
        kc_name_index = KILL_CHAIN_NAMES.index("custom") if is_custom_default else (KILL_CHAIN_NAMES.index(default_kc_name) if default_kc_name in KILL_CHAIN_NAMES else 0)
        selected_kc_name = st.selectbox("Kill Chain Name", options=KILL_CHAIN_NAMES, index=kc_name_index, key=kc_name_widget_key, help="Select a standard kill chain or 'custom'.")
        form_values[f'{data_key_prefix}_kc_name'] = selected_kc_name
        if selected_kc_name == "custom":
            custom_kc_val = default_kc_name if is_custom_default else ""
            custom_phase_val = default_phase_name if is_custom_default else ""
            form_values[f'{data_key_prefix}_custom_kc_name'] = st.text_input("Custom Kill Chain Name", value=custom_kc_val, key=custom_kc_name_widget_key, help="Enter custom name (lowercase, hyphenated).")
            form_values[f'{data_key_prefix}_phase_name'] = st.text_input("Custom Phase Name", value=custom_phase_val, key=custom_phase_name_widget_key, help="Enter custom phase name (lowercase, hyphenated).")
        elif selected_kc_name:
            available_phases = KILL_CHAIN_PHASES.get(selected_kc_name, [])
            phase_default_val = ""
            if data.get('kill_chain_phases') and data['kill_chain_phases']:
                 first_phase = data['kill_chain_phases'][0]
                 if first_phase.get('kill_chain_name') == selected_kc_name: phase_default_val = first_phase.get('phase_name', "")
            phase_name_index = available_phases.index(phase_default_val) if phase_default_val in available_phases else 0
            form_values[f'{data_key_prefix}_phase_name'] = st.selectbox("Phase Name", options=available_phases, index=phase_name_index, key=phase_name_select_key)
        else: form_values[f'{data_key_prefix}_phase_name'] = None

    # --- Type Specific Fields ---
    if obj_type == 'attack-pattern':
        form_values['ap_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_ap_aliases")
        kill_chain_input("ap")
    elif obj_type == 'campaign': # UPDATED
        form_values['c_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_c_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['c_objective'] = st.text_area("Objective", value=_get_default(data, 'objective'), key=f"{key_prefix}_c_objective")
    elif obj_type == 'identity':
        form_values['id_identity_class'] = st.selectbox("Identity Class", options=IDENTITY_CLASS_OV, index=IDENTITY_CLASS_OV.index(_get_default(data, 'identity_class', "")), key=f"{key_prefix}_id_class")
        form_values['id_sectors'] = st.multiselect("Sectors", options=INDUSTRY_SECTOR_OV[1:], default=data.get('sectors', []), key=f"{key_prefix}_id_sectors")
        form_values['id_contact_information'] = st.text_input("Contact Information", value=_get_default(data, 'contact_information'), key=f"{key_prefix}_id_contact")
    elif obj_type == 'indicator': # UPDATED
        form_values['ind_indicator_types'] = st.multiselect("Indicator Types", options=INDICATOR_TYPES_OV[1:], default=data.get('indicator_types', []), key=f"{key_prefix}_ind_types")
        form_values['ind_pattern_type'] = st.selectbox("Pattern Type (Required)", options=PATTERN_TYPES_OV, index=PATTERN_TYPES_OV.index(_get_default(data, 'pattern_type', "stix")), key=f"{key_prefix}_ind_patt_type")
        form_values['ind_pattern'] = st.text_area("Pattern (Required)", value=_get_default(data, 'pattern'), key=f"{key_prefix}_ind_pattern")
        datetime_input("Valid From", "valid_from", required=True); datetime_input("Valid Until", "valid_until")
        kill_chain_input("ind")
    elif obj_type == 'infrastructure': # UPDATED
        form_values['inf_infrastructure_types'] = st.multiselect("Infrastructure Types", options=INFRASTRUCTURE_TYPES_OV[1:], default=data.get('infrastructure_types', []), key=f"{key_prefix}_inf_types")
        form_values['inf_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_inf_aliases")
        kill_chain_input("inf")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
    elif obj_type == 'intrusion-set': # UPDATED
        form_values['is_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_is_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['is_goals_str'] = st.text_area("Goals (one per line)", value=_list_to_text(data, 'goals'), key=f"{key_prefix}_is_goals")
        form_values['is_resource_level'] = st.selectbox("Resource Level", options=ATTACK_RESOURCE_LEVEL_OV, index=ATTACK_RESOURCE_LEVEL_OV.index(_get_default(data, 'resource_level', "")), key=f"{key_prefix}_is_resource_level")
        form_values['is_primary_motivation'] = st.selectbox("Primary Motivation", options=ATTACK_MOTIVATION_OV, index=ATTACK_MOTIVATION_OV.index(_get_default(data, 'primary_motivation', "")), key=f"{key_prefix}_is_primary_motivation")
        form_values['is_secondary_motivations'] = st.multiselect("Secondary Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('secondary_motivations', []), key=f"{key_prefix}_is_secondary_motivations")
    elif obj_type == 'location':
         # --- REMOVED st.button for maps link from here ---
         form_values['loc_region'] = st.selectbox("Region", options=REGION_OV, index=REGION_OV.index(_get_default(data, 'region', "")), key=f"{key_prefix}_loc_region")
         form_values['loc_country'] = st.text_input("Country (ISO 3166-1 alpha-2)", value=_get_default(data, 'country'), key=f"{key_prefix}_loc_country", help="Use 2-letter country code (e.g., US, GB)")
         form_values['loc_administrative_area'] = st.text_input("Administrative Area (e.g., state)", value=_get_default(data, 'administrative_area'), key=f"{key_prefix}_loc_admin_area")
         form_values['loc_city'] = st.text_input("City", value=_get_default(data, 'city'), key=f"{key_prefix}_loc_city")
         form_values['loc_street_address'] = st.text_input("Street Address", value=_get_default(data, 'street_address'), key=f"{key_prefix}_loc_street")
         form_values['loc_postal_code'] = st.text_input("Postal Code", value=_get_default(data, 'postal_code'), key=f"{key_prefix}_loc_postal")
         form_values['loc_latitude'] = st.number_input("Latitude", value=data.get('latitude'), format="%.6f", key=f"{key_prefix}_loc_lat", help="e.g., 48.8584")
         form_values['loc_longitude'] = st.number_input("Longitude", value=data.get('longitude'), format="%.6f", key=f"{key_prefix}_loc_lon", help="e.g., 2.2945")
         form_values['loc_precision'] = st.number_input("Precision (meters)", value=data.get('precision'), min_value=0.0, format="%.1f", key=f"{key_prefix}_loc_prec")
    elif obj_type == 'malware': # UPDATED
         form_values['mal_malware_types'] = st.multiselect("Malware Types", options=MALWARE_TYPES_OV[1:], default=data.get('malware_types', []), key=f"{key_prefix}_mal_types")
         form_values['mal_is_family'] = st.checkbox("Is Family?", value=data.get('is_family', False), key=f"{key_prefix}_mal_is_family")
         form_values['mal_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_mal_aliases")
         kill_chain_input("mal")
         datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
         form_values['mal_os_execution_envs_str'] = st.text_area("OS Execution Envs (one per line)", value=_list_to_text(data, 'os_execution_envs'), key=f"{key_prefix}_mal_os")
         form_values['mal_architecture_execution_envs_str'] = st.text_area("Architecture Execution Envs (e.g., x86)", value=_list_to_text(data, 'architecture_execution_envs'), key=f"{key_prefix}_mal_arch")
         form_values['mal_implementation_languages_str'] = st.text_area("Implementation Languages (e.g., c++)", value=_list_to_text(data, 'implementation_languages'), key=f"{key_prefix}_mal_langs")
         form_values['mal_capabilities_str'] = st.text_area("Capabilities (one per line)", value=_list_to_text(data, 'capabilities'), key=f"{key_prefix}_mal_caps")
         form_values['mal_sample_refs_str'] = st.text_area("Sample Refs (STIX IDs, one per line)", value=_list_to_text(data, 'sample_refs'), key=f"{key_prefix}_mal_samples")
    elif obj_type == 'note': # UPDATED
        form_values['note_abstract'] = st.text_area("Abstract", value=_get_default(data, 'abstract'), key=f"{key_prefix}_note_abstract")
        form_values['note_content'] = st.text_area("Content (Required)", value=_get_default(data, 'content'), key=f"{key_prefix}_note_content")
        form_values['note_authors_str'] = st.text_area("Authors (one per line)", value=_list_to_text(data, 'authors'), key=f"{key_prefix}_note_authors")
        form_values['note_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_note_obj_refs")
    elif obj_type == 'observed-data':
        datetime_input("First Observed", "first_observed", required=True); datetime_input("Last Observed", "last_observed", required=True)
        form_values['obs_number_observed'] = st.number_input("Number Observed (Required)", min_value=1, value=data.get('number_observed', 1), key=f"{key_prefix}_obs_num")
        form_values['obs_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_obs_obj_refs", help="IDs of SCOs or SROs observed")
    elif obj_type == 'report': # UPDATED
        # Name and Description are handled by the generic fields at the top
        form_values['rep_report_types'] = st.multiselect("Report Types (Required)", options=REPORT_TYPES_OV[1:], default=data.get('report_types', []), key=f"{key_prefix}_rep_types")
        datetime_input("Published Date", "published", required=True)
        form_values['rep_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_rep_obj_refs")
    elif obj_type == 'threat-actor':
        form_values['ta_threat_actor_types'] = st.multiselect("Threat Actor Types (Required)", options=THREAT_ACTOR_TYPES_OV[1:], default=data.get('threat_actor_types', []), key=f"{key_prefix}_ta_types")
        form_values['ta_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_ta_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['ta_roles'] = st.multiselect("Roles", options=THREAT_ACTOR_ROLES_OV[1:], default=data.get('roles', []), key=f"{key_prefix}_ta_roles")
        form_values['ta_goals_str'] = st.text_area("Goals (one per line)", value=_list_to_text(data, 'goals'), key=f"{key_prefix}_ta_goals")
        form_values['ta_sophistication'] = st.selectbox("Sophistication", options=THREAT_ACTOR_SOPHISTICATION_OV, index=THREAT_ACTOR_SOPHISTICATION_OV.index(_get_default(data, 'sophistication', "")), key=f"{key_prefix}_ta_sophistication")
        form_values['ta_resource_level'] = st.selectbox("Resource Level", options=ATTACK_RESOURCE_LEVEL_OV, index=ATTACK_RESOURCE_LEVEL_OV.index(_get_default(data, 'resource_level', "")), key=f"{key_prefix}_ta_resource_level")
        form_values['ta_primary_motivation'] = st.selectbox("Primary Motivation", options=ATTACK_MOTIVATION_OV, index=ATTACK_MOTIVATION_OV.index(_get_default(data, 'primary_motivation', "")), key=f"{key_prefix}_ta_primary_motivation")
        form_values['ta_secondary_motivations'] = st.multiselect("Secondary Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('secondary_motivations', []), key=f"{key_prefix}_ta_secondary_motivations")
        form_values['ta_personal_motivations'] = st.multiselect("Personal Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('personal_motivations', []), key=f"{key_prefix}_ta_personal_motivations")
    elif obj_type == 'tool': # UPDATED
         form_values['t_tool_types'] = st.multiselect("Tool Types", options=TOOL_TYPES_OV[1:], default=data.get('tool_types', []), key=f"{key_prefix}_t_types")
         form_values['t_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_t_aliases")
         kill_chain_input("t")
         form_values['t_tool_version'] = st.text_input("Tool Version", value=_get_default(data, 'tool_version'), key=f"{key_prefix}_t_version")
    elif obj_type == 'vulnerability':
         form_values['vuln_cvssv2_score'] = st.number_input("CVSSv2 Score", value=data.get('cvssV2_score'), min_value=0.0, max_value=10.0, format="%.1f", key=f"{key_prefix}_vuln_cvss2")
         form_values['vuln_cvssv3_score'] = st.number_input("CVSSv3 Score", value=data.get('cvssV3_score'), min_value=0.0, max_value=10.0, format="%.1f", key=f"{key_prefix}_vuln_cvss3")
    elif obj_type == 'x509-certificate':
        form_values['cert_is_self_signed'] = st.checkbox("Is Self-Signed?", value=data.get('is_self_signed', False), key=f"{key_prefix}_cert_self_signed")
        form_values['cert_hashes_str'] = st.text_area("Hashes (HASH_ALGO:value, one per line)", value=_hashes_to_text(data.get('hashes')), key=f"{key_prefix}_cert_hashes")
        form_values['cert_version'] = st.text_input("Version", value=_get_default(data, 'version'), key=f"{key_prefix}_cert_version")
        form_values['cert_serial_number'] = st.text_input("Serial Number", value=_get_default(data, 'serial_number'), key=f"{key_prefix}_cert_serial")
        form_values['cert_signature_algorithm'] = st.text_input("Signature Algorithm", value=_get_default(data, 'signature_algorithm'), key=f"{key_prefix}_cert_sig_algo")
        form_values['cert_issuer'] = st.text_input("Issuer", value=_get_default(data, 'issuer'), key=f"{key_prefix}_cert_issuer")
        datetime_input("Validity Not Before", "validity_not_before")
        datetime_input("Validity Not After", "validity_not_after")
        form_values['cert_subject'] = st.text_input("Subject", value=_get_default(data, 'subject'), key=f"{key_prefix}_cert_subject")
        form_values['cert_subject_public_key_algorithm'] = st.text_input("Subject Public Key Algorithm", value=_get_default(data, 'subject_public_key_algorithm'), key=f"{key_prefix}_cert_subj_pk_algo")
        form_values['cert_subject_public_key_modulus'] = st.text_area("Subject Public Key Modulus", value=_get_default(data, 'subject_public_key_modulus'), key=f"{key_prefix}_cert_subj_pk_mod")
        form_values['cert_subject_public_key_exponent'] = st.number_input("Subject Public Key Exponent", value=data.get('subject_public_key_exponent'), step=1, key=f"{key_prefix}_cert_subj_pk_exp")
        default_ext_json = json.dumps(data.get('x509_v3_extensions'), indent=2) if data.get('x509_v3_extensions') else ""
        form_values['cert_x509_v3_extensions_json'] = st.text_area("X.509 v3 Extensions (JSON)", value=default_ext_json, height=150, key=f"{key_prefix}_cert_ext")
    elif obj_type == 'domain-name':
        form_values['domain_value'] = st.text_input("Value (Required)", value=_get_default(data, 'value'), key=f"{key_prefix}_domain_value")
        form_values['domain_resolves_to_refs_str'] = st.text_area("Resolves To Refs (STIX IDs, one per line)", value=_list_to_text(data, 'resolves_to_refs'), key=f"{key_prefix}_domain_resolves")
    # --- ADDED software ---
    elif obj_type == 'software':
        # Name and description handled above
        form_values['sw_cpe'] = st.text_input("CPE", value=_get_default(data, 'cpe'), key=f"{key_prefix}_sw_cpe")
        form_values['sw_swid'] = st.text_input("SWID", value=_get_default(data, 'swid'), key=f"{key_prefix}_sw_swid")
        form_values['sw_languages_str'] = st.text_area("Languages (one per line)", value=_list_to_text(data, 'languages'), key=f"{key_prefix}_sw_langs")
        form_values['sw_vendor'] = st.text_input("Vendor", value=_get_default(data, 'vendor'), key=f"{key_prefix}_sw_vendor")
        form_values['sw_version'] = st.text_input("Version", value=_get_default(data, 'version'), key=f"{key_prefix}_sw_version")
    # --- END software ---

    # --- External Reference Fields (Only if SDO/Relationship, not SCO/Note) ---
    if obj_type not in ['x509-certificate', 'domain-name', 'note', 'software', 'file', 'ipv4-addr', 'ipv6-addr', 'url', 'directory', 'email-addr', 'email-message', 'mac-addr', 'mutex', 'network-traffic', 'process', 'user-account', 'windows-registry-key']:
        st.subheader("External Reference (Optional)")
        ext_ref_data = data.get('external_references', [{}])[0]
        form_values['ext_ref_source_name'] = st.text_input("Source Name", value=_get_default(ext_ref_data, 'source_name'), key=f"{key_prefix}_ext_ref_source")
        form_values['ext_ref_description'] = st.text_input("Description", value=_get_default(ext_ref_data, 'description'), key=f"{key_prefix}_ext_ref_desc")
        form_values['ext_ref_url'] = st.text_input("URL", value=_get_default(ext_ref_data, 'url'), key=f"{key_prefix}_ext_ref_url")
        form_values['ext_ref_external_id'] = st.text_input("External ID", value=_get_default(ext_ref_data, 'external_id'), key=f"{key_prefix}_ext_ref_ext_id")
        form_values['ext_ref_hashes_str'] = st.text_area("Hashes (HASH_ALGO:value)", value=_ext_ref_hashes_to_text(data.get('external_references')), key=f"{key_prefix}_ext_ref_hashes")

    return form_values


def parse_form_data_to_stix_args(form_data, obj_type):
    """Converts raw form data into a dictionary suitable for stix2 constructors or updates."""
    obj_args = {}
    def parse_text_area(text_area_str): return [item.strip() for item in text_area_str.splitlines() if item.strip()]
    def format_stix_timestamp(date_val, time_val):
        if date_val is None: return None
        time_val = time_val or dt_time(0, 0, 0)
        try:
            combined_dt = datetime.combine(date_val, time_val).replace(tzinfo=timezone.utc)
            return combined_dt.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + "Z"
        except Exception as e: st.error(f"Error combining date/time: {e}"); return None
    def parse_hashes_str(hashes_str):
        hashes_dict = {}
        for line in hashes_str.splitlines():
            if ':' in line:
                parts = line.split(':', 1); algo = parts[0].strip().upper(); hash_val = parts[1].strip()
                if algo in HASH_ALGO_OV and algo != "": hashes_dict[algo] = hash_val
        return hashes_dict if hashes_dict else None

    # Generic Fields (if applicable)
    if form_data.get('name'): obj_args['name'] = form_data['name']
    if form_data.get('description'): obj_args['description'] = form_data['description']

    # Type Specific Parsing
    if obj_type == 'attack-pattern':
        if form_data.get('ap_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['ap_aliases_str'])
    elif obj_type == 'campaign': # UPDATED
        if form_data.get('c_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['c_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('c_objective'): obj_args['objective'] = form_data['c_objective']
    elif obj_type == 'identity':
        if form_data.get('id_identity_class'): obj_args['identity_class'] = form_data['id_identity_class']
        if form_data.get('id_sectors'): obj_args['sectors'] = form_data['id_sectors']
        if form_data.get('id_contact_information'): obj_args['contact_information'] = form_data['id_contact_information']
    elif obj_type == 'indicator': # UPDATED
        if form_data.get('ind_indicator_types'): obj_args['indicator_types'] = form_data['ind_indicator_types']
        if form_data.get('ind_pattern_type'): obj_args['pattern_type'] = form_data['ind_pattern_type'] # Required
        if form_data.get('ind_pattern'): obj_args['pattern'] = form_data['ind_pattern'] # Required
        ts = format_stix_timestamp(form_data.get('valid_from_date'), form_data.get('valid_from_time')); # Required
        if ts: obj_args['valid_from'] = ts
        ts = format_stix_timestamp(form_data.get('valid_until_date'), form_data.get('valid_until_time')); obj_args.update({'valid_until': ts} if ts else {})
    elif obj_type == 'infrastructure': # UPDATED
        if form_data.get('inf_infrastructure_types'): obj_args['infrastructure_types'] = form_data['inf_infrastructure_types']
        if form_data.get('inf_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['inf_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
    elif obj_type == 'intrusion-set': # UPDATED
        if form_data.get('is_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['is_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('is_goals_str'): obj_args['goals'] = parse_text_area(form_data['is_goals_str'])
        if form_data.get('is_resource_level'): obj_args['resource_level'] = form_data['is_resource_level']
        if form_data.get('is_primary_motivation'): obj_args['primary_motivation'] = form_data['is_primary_motivation']
        if form_data.get('is_secondary_motivations'): obj_args['secondary_motivations'] = form_data['is_secondary_motivations']
    elif obj_type == 'location':
        if form_data.get('loc_region'): obj_args['region'] = form_data['loc_region']
        if form_data.get('loc_country'): obj_args['country'] = form_data['loc_country']
        if form_data.get('loc_administrative_area'): obj_args['administrative_area'] = form_data['loc_administrative_area']
        if form_data.get('loc_city'): obj_args['city'] = form_data['loc_city']
        if form_data.get('loc_street_address'): obj_args['street_address'] = form_data['loc_street_address']
        if form_data.get('loc_postal_code'): obj_args['postal_code'] = form_data['loc_postal_code']
        if form_data.get('loc_latitude') is not None:
            try: obj_args['latitude'] = float(form_data['loc_latitude'])
            except (ValueError, TypeError): pass
        if form_data.get('loc_longitude') is not None:
             try: obj_args['longitude'] = float(form_data['loc_longitude'])
             except (ValueError, TypeError): pass
        if form_data.get('loc_precision') is not None:
             try: obj_args['precision'] = float(form_data['loc_precision'])
             except (ValueError, TypeError): pass
    elif obj_type == 'malware': # UPDATED
        if form_data.get('mal_malware_types'): obj_args['malware_types'] = form_data['mal_malware_types']
        obj_args['is_family'] = form_data.get('mal_is_family', False)
        if form_data.get('mal_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['mal_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('mal_os_execution_envs_str'): obj_args['os_execution_envs'] = parse_text_area(form_data['mal_os_execution_envs_str'])
        if form_data.get('mal_architecture_execution_envs_str'): obj_args['architecture_execution_envs'] = parse_text_area(form_data['mal_architecture_execution_envs_str'])
        if form_data.get('mal_implementation_languages_str'): obj_args['implementation_languages'] = parse_text_area(form_data['mal_implementation_languages_str'])
        if form_data.get('mal_capabilities_str'): obj_args['capabilities'] = parse_text_area(form_data['mal_capabilities_str'])
        if form_data.get('mal_sample_refs_str'): obj_args['sample_refs'] = parse_text_area(form_data['mal_sample_refs_str'])
    elif obj_type == 'note': # UPDATED
        if form_data.get('note_abstract'): obj_args['abstract'] = form_data['note_abstract']
        if form_data.get('note_content'): obj_args['content'] = form_data['note_content'] # Required
        if form_data.get('note_authors_str'):
            authors = parse_text_area(form_data['note_authors_str'])
            if authors: obj_args['authors'] = authors
        if form_data.get('note_object_refs_str'):
            refs = parse_text_area(form_data['note_object_refs_str'])
            if refs: obj_args['object_refs'] = refs # Required
    elif obj_type == 'observed-data':
        ts = format_stix_timestamp(form_data.get('first_observed_date'), form_data.get('first_observed_time')); obj_args.update({'first_observed': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_observed_date'), form_data.get('last_observed_time')); obj_args.update({'last_observed': ts} if ts else {})
        if form_data.get('obs_number_observed') is not None: obj_args['number_observed'] = form_data['obs_number_observed']
        if form_data.get('obs_object_refs_str'): obj_args['object_refs'] = parse_text_area(form_data['obs_object_refs_str'])
    elif obj_type == 'report': # UPDATED
        # Name and Description handled by generic fields
        if form_data.get('rep_report_types'): obj_args['report_types'] = form_data['rep_report_types'] # Required
        ts = format_stix_timestamp(form_data.get('published_date'), form_data.get('published_time')) # Required
        if ts: obj_args['published'] = ts
        if form_data.get('rep_object_refs_str'):
            refs = parse_text_area(form_data['rep_object_refs_str'])
            if refs: obj_args['object_refs'] = refs # Required
    elif obj_type == 'threat-actor':
        if form_data.get('ta_threat_actor_types'): obj_args['threat_actor_types'] = form_data['ta_threat_actor_types']
        if form_data.get('ta_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['ta_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('ta_roles'): obj_args['roles'] = form_data['ta_roles']
        if form_data.get('ta_goals_str'): obj_args['goals'] = parse_text_area(form_data['ta_goals_str'])
        if form_data.get('ta_sophistication'): obj_args['sophistication'] = form_data['ta_sophistication']
        if form_data.get('ta_resource_level'): obj_args['resource_level'] = form_data['ta_resource_level']
        if form_data.get('ta_primary_motivation'): obj_args['primary_motivation'] = form_data['ta_primary_motivation']
        if form_data.get('ta_secondary_motivations'): obj_args['secondary_motivations'] = form_data['ta_secondary_motivations']
        if form_data.get('ta_personal_motivations'): obj_args['personal_motivations'] = form_data['ta_personal_motivations']
    elif obj_type == 'tool': # UPDATED
        if form_data.get('t_tool_types'): obj_args['tool_types'] = form_data['t_tool_types']
        if form_data.get('t_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['t_aliases_str'])
        if form_data.get('t_tool_version'): obj_args['tool_version'] = form_data['t_tool_version']
    elif obj_type == 'vulnerability':
        if form_data.get('vuln_cvssv2_score') is not None: obj_args['cvssV2_score'] = form_data['vuln_cvssv2_score']
        if form_data.get('vuln_cvssv3_score') is not None: obj_args['cvssV3_score'] = form_data['vuln_cvssv3_score']
    elif obj_type == 'x509-certificate':
        obj_args['is_self_signed'] = form_data.get('cert_is_self_signed', False)
        if form_data.get('cert_hashes_str'):
            hashes = parse_hashes_str(form_data['cert_hashes_str'])
            if hashes: obj_args['hashes'] = hashes
        if form_data.get('cert_version'): obj_args['version'] = form_data['cert_version']
        if form_data.get('cert_serial_number'): obj_args['serial_number'] = form_data['cert_serial_number']
        if form_data.get('cert_signature_algorithm'): obj_args['signature_algorithm'] = form_data['cert_signature_algorithm']
        if form_data.get('cert_issuer'): obj_args['issuer'] = form_data['cert_issuer']
        ts = format_stix_timestamp(form_data.get('validity_not_before_date'), form_data.get('validity_not_before_time'))
        if ts: obj_args['validity_not_before'] = ts
        ts = format_stix_timestamp(form_data.get('validity_not_after_date'), form_data.get('validity_not_after_time'))
        if ts: obj_args['validity_not_after'] = ts
        if form_data.get('cert_subject'): obj_args['subject'] = form_data['cert_subject']
        if form_data.get('cert_subject_public_key_algorithm'): obj_args['subject_public_key_algorithm'] = form_data['cert_subject_public_key_algorithm']
        if form_data.get('cert_subject_public_key_modulus'): obj_args['subject_public_key_modulus'] = form_data['cert_subject_public_key_modulus']
        if form_data.get('cert_subject_public_key_exponent') is not None:
             try: obj_args['subject_public_key_exponent'] = int(form_data['cert_subject_public_key_exponent'])
             except (ValueError, TypeError): st.warning("Invalid input for public key exponent, expected integer.")
        if form_data.get('cert_x509_v3_extensions_json'):
            try:
                ext_data = json.loads(form_data['cert_x509_v3_extensions_json'])
                if isinstance(ext_data, dict): obj_args['x509_v3_extensions'] = ext_data
                else: st.warning("X.509 v3 Extensions input is not valid JSON dictionary, skipping.")
            except json.JSONDecodeError: st.warning("X.509 v3 Extensions input is not valid JSON, skipping.")
    elif obj_type == 'domain-name':
        if form_data.get('domain_value'): obj_args['value'] = form_data['domain_value'] # Required
        if form_data.get('domain_resolves_to_refs_str'):
            refs = parse_text_area(form_data['domain_resolves_to_refs_str'])
            if refs: obj_args['resolves_to_refs'] = refs
    # --- ADDED software Parsing ---
    elif obj_type == 'software':
        # Name and description parsed above
        if form_data.get('sw_cpe'): obj_args['cpe'] = form_data['sw_cpe']
        if form_data.get('sw_swid'): obj_args['swid'] = form_data['sw_swid']
        if form_data.get('sw_languages_str'): obj_args['languages'] = parse_text_area(form_data['sw_languages_str'])
        if form_data.get('sw_vendor'): obj_args['vendor'] = form_data['sw_vendor']
        if form_data.get('sw_version'): obj_args['version'] = form_data['sw_version']
    # --- END software Parsing ---

    # --- Kill Chain Phase Processing (Applies to relevant types) ---
    kc_prefix_map = {'attack-pattern': 'ap', 'indicator': 'ind', 'infrastructure': 'inf', 'malware': 'mal', 'tool': 't'}
    kc_prefix = kc_prefix_map.get(obj_type)
    if kc_prefix:
        selected_kc_name = form_data.get(f'{kc_prefix}_kc_name')
        phase_name = form_data.get(f'{kc_prefix}_phase_name')
        final_kc_name = None
        if selected_kc_name == "custom":
            final_kc_name = form_data.get(f'{kc_prefix}_custom_kc_name')
        elif selected_kc_name and selected_kc_name != "custom":
            final_kc_name = selected_kc_name
        if final_kc_name and phase_name:
            obj_args['kill_chain_phases'] = [{'kill_chain_name': final_kc_name.lower().replace(" ", "-"), 'phase_name': phase_name.lower().replace(" ", "-")}]
        elif 'kill_chain_phases' in obj_args: del obj_args['kill_chain_phases'] # Clear if no valid selection

    # --- External Reference (Only if SDO/Relationship, not SCO/Note) ---
    if obj_type not in ['x509-certificate', 'domain-name', 'note', 'software', 'file', 'ipv4-addr', 'ipv6-addr', 'url', 'directory', 'email-addr', 'email-message', 'mac-addr', 'mutex', 'network-traffic', 'process', 'user-account', 'windows-registry-key']:
        ext_ref_source = form_data.get('ext_ref_source_name')
        ext_ref_desc = form_data.get('ext_ref_description')
        ext_ref_url = form_data.get('ext_ref_url')
        ext_ref_ext_id = form_data.get('ext_ref_external_id')
        ext_ref_hashes_str = form_data.get('ext_ref_hashes_str')
        if ext_ref_source and (ext_ref_desc or ext_ref_url or ext_ref_ext_id or ext_ref_hashes_str): # Check if any ext ref field has value
            ext_ref = {"source_name": ext_ref_source}
            if ext_ref_desc: ext_ref["description"] = ext_ref_desc
            if ext_ref_url: ext_ref["url"] = ext_ref_url
            if ext_ref_ext_id: ext_ref["external_id"] = ext_ref_ext_id
            if ext_ref_hashes_str:
                hashes = parse_hashes_str(ext_ref_hashes_str)
                if hashes: ext_ref["hashes"] = hashes
            obj_args["external_references"] = [ext_ref]
        elif "external_references" in obj_args: # Remove if source name is now empty
             del obj_args["external_references"]


    # Remove keys with empty/None values unless required or specific cases
    required_fields = {
        'indicator': ['pattern_type', 'pattern', 'valid_from'],
        'note': ['content', 'object_refs'],
        'observed-data': ['first_observed', 'last_observed', 'number_observed', 'object_refs'],
        'report': ['name', 'report_types', 'published', 'object_refs'],
        'threat-actor': ['threat_actor_types'],
        'x509-certificate': [],
        'domain-name': ['value'],
        'software': ['name'] # Name is required for software
    }
    args_copy = obj_args.copy()
    for key, value in args_copy.items():
        is_required = key in required_fields.get(obj_type, [])
        if key == 'is_family' or key == 'is_self_signed': continue # Booleans, keep False if needed
        is_timestamp_field = key in ['first_seen', 'last_seen', 'valid_until', 'published', 'first_observed', 'last_observed', 'valid_from', 'validity_not_before', 'validity_not_after']
        # Remove if not required AND (value is None OR empty string OR empty list)
        if not is_required and (value is None or value == "" or value == []):
            del obj_args[key]

    return obj_args


# --- Main App ---
# (Rest of the Main App logic remains the same as previous version)
st.title("STIX 2.1 Visualizer & Editor")
load_status_placeholder = st.empty()

# --- Sidebar ---
with st.sidebar:
    # --- Load Bundle ---
    with st.expander("Load STIX 2.1 Bundle", expanded=True):
        uploaded_file = st.file_uploader("Upload STIX 2.1 JSON bundle", type=["json"], key="stix_uploader_widget")
        if uploaded_file is not None and uploaded_file != st.session_state.uploaded_file_state:
            st.session_state.uploaded_file_state = uploaded_file
            load_status_placeholder.empty()
            st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None
        process_button = st.button("Load and Process Bundle", disabled=(st.session_state.uploaded_file_state is None), key="load_process_button")

    # --- Processing Logic ---
    if st.session_state.get("load_process_button") and st.session_state.uploaded_file_state is not None:
        with st.status(f"Loading '{st.session_state.uploaded_file_state.name}'...", expanded=True) as status:
            # (Processing logic remains the same)
            try:
                current_uploaded_file = st.session_state.uploaded_file_state
                load_status_placeholder.info(f"Processing '{current_uploaded_file.name}'...")
                status.write("🔄 Resetting current graph..."); time.sleep(0.1)
                st.session_state.objects = []; st.session_state.nodes = []; st.session_state.edges = []
                st.session_state.current_selection = None; st.session_state.rel_source_sel = None; st.session_state.rel_target_sel = None
                st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None
                status.write(f"📖 Reading file '{current_uploaded_file.name}'..."); time.sleep(0.1)
                bundle_content_bytes = current_uploaded_file.getvalue()
                if not bundle_content_bytes: status.update(label="Error: Uploaded file is empty.", state="error", expanded=True); load_status_placeholder.error("❌ Error: Uploaded file is empty."); st.stop()
                try: bundle_content_str = bundle_content_bytes.decode('utf-8-sig')
                except UnicodeDecodeError:
                    try: bundle_content_str = bundle_content_bytes.decode('utf-8')
                    except UnicodeDecodeError as decode_e: status.update(label=f"Error decoding file: {decode_e}", state="error", expanded=True); load_status_placeholder.error(f"❌ Error decoding file: Use UTF-8 encoding. Details: {decode_e}"); st.stop()
                status.write("🧩 Parsing JSON data..."); time.sleep(0.1)
                try: bundle_json = json.loads(bundle_content_str)
                except json.JSONDecodeError as json_e: status.update(label=f"JSON Decode Error: {json_e}", state="error", expanded=True); load_status_placeholder.error(f"❌ Invalid JSON: {json_e}"); st.stop()
                status.write("🔬 Parsing STIX objects..."); time.sleep(0.1)
                try:
                    bundle = parse(bundle_json, allow_custom=True)
                    if not isinstance(bundle, Bundle): status.update(label="Error: Parsed data is not a valid STIX Bundle.", state="error", expanded=True); load_status_placeholder.error("❌ Error: File does not contain a valid STIX Bundle object."); st.stop()
                except Exception as parse_e: status.update(label=f"STIX Parsing Error: {parse_e}", state="error", expanded=True); load_status_placeholder.error(f"❌ Error parsing STIX content: {parse_e}"); st.stop()
                status.write("🏗️ Building graph elements..."); time.sleep(0.1)
                temp_nodes, temp_edges, temp_objects = [], [], []; skipped_objects = 0; processed_count = 0
                total_objects = len(bundle.objects) if hasattr(bundle, 'objects') and bundle.objects else 0
                if total_objects > 0:
                    progress_bar = status.progress(0)
                    for i, obj in enumerate(bundle.objects):
                        try:
                            if not hasattr(obj, 'id') or not hasattr(obj, 'type'): skipped_objects += 1; continue
                            obj_dict = json.loads(obj.serialize()); temp_objects.append(obj_dict)
                            obj_type = obj_dict['type']; obj_id = obj_dict['id']
                            if obj_type == 'relationship':
                                if 'source_ref' in obj_dict and 'target_ref' in obj_dict and 'relationship_type' in obj_dict: temp_edges.append({'data': {'id': obj_id, 'source': obj_dict['source_ref'], 'target': obj_dict['target_ref'], 'label': obj_dict['relationship_type']}})
                                else: skipped_objects += 1
                            elif obj_type != 'marking-definition':
                                # Use value or serial_number/subject/abstract for label if name missing
                                label = obj_dict.get('name', obj_dict.get('value'))
                                if obj_type == 'x509-certificate' and not label:
                                     label = obj_dict.get('serial_number', obj_dict.get('subject', obj_id))
                                elif obj_type == 'note' and not label:
                                     label = obj_dict.get('abstract', obj_id) # Use abstract for note if name missing
                                elif not label:
                                     label = obj_id
                                temp_nodes.append({'data': {'id': obj_id, 'label': label}})
                            processed_count += 1
                        except Exception as obj_proc_e: skipped_objects += 1
                        progress_bar.progress((i + 1) / total_objects, text=f"Processing object {i+1}/{total_objects}")
                    progress_bar.empty()
                st.session_state.objects = temp_objects; st.session_state.nodes = temp_nodes; st.session_state.edges = temp_edges
                success_msg = f"Loaded {len(temp_objects)} objects ({len(temp_nodes)} nodes, {len(temp_edges)} edges)."
                if skipped_objects > 0: success_msg += f" Skipped {skipped_objects} invalid/unsupported objects."
                status.update(label="Loading Complete!", state="complete", expanded=False)
                load_status_placeholder.success(f"✅ {success_msg}")
                st.rerun()
            except Exception as e:
                error_label = f"Unexpected Error: {e}"; status.update(label=error_label, state="error", expanded=True); load_status_placeholder.error(f"❌ An unexpected error occurred: {e}")

    elif st.session_state.get("load_process_button") and st.session_state.uploaded_file_state is None:
        load_status_placeholder.warning("⚠️ Please upload a file first.")

    # --- Add Object ---
    with st.expander("Add STIX Object", expanded=False):
        def update_add_form_type():
            st.session_state.add_form_selected_type = st.session_state.add_obj_type_select_widget
            st.session_state.editing_object_id = None
            st.session_state.editing_relationship_id = None
        current_add_type_index = 0
        if st.session_state.add_form_selected_type in ALL_OBJECT_TYPES: current_add_type_index = ALL_OBJECT_TYPES.index(st.session_state.add_form_selected_type)
        obj_type_selection = st.selectbox("Object Type", ALL_OBJECT_TYPES, key="add_obj_type_select_widget", index=current_add_type_index, on_change=update_add_form_type)
        add_obj_type = st.session_state.add_form_selected_type

        # --- Form for Adding Objects ---
        with st.form(f"add_object_detail_form_{add_obj_type}", clear_on_submit=True):
            add_form_data = generate_object_form_fields(add_obj_type, key_prefix="add")
            add_obj_submit = st.form_submit_button(f"Create {add_obj_type} Object") # Changed label slightly

            if add_obj_submit:
                validation_passed = True; error_messages = []
                # --- ADDED Validation ---
                if add_obj_type == 'domain-name' and not add_form_data.get('domain_value'):
                    error_messages.append("Domain Name 'Value' is required.")
                    validation_passed = False
                if add_obj_type == 'note' and not add_form_data.get('note_content'):
                    error_messages.append("Note 'Content' is required.")
                    validation_passed = False
                if add_obj_type == 'note' and not add_form_data.get('note_object_refs_str'):
                    error_messages.append("Note 'Object Refs' are required.")
                    validation_passed = False
                if add_obj_type == 'report' and not add_form_data.get('name'):
                    error_messages.append("Report 'Name' is required.")
                    validation_passed = False
                if add_obj_type == 'report' and not add_form_data.get('rep_report_types'):
                    error_messages.append("Report 'Report Types' are required.")
                    validation_passed = False
                if add_obj_type == 'report' and (not add_form_data.get('published_date') or not add_form_data.get('published_time')):
                    error_messages.append("Report 'Published Date/Time' is required.")
                    validation_passed = False
                if add_obj_type == 'report' and not add_form_data.get('rep_object_refs_str'):
                    error_messages.append("Report 'Object Refs' are required.")
                    validation_passed = False
                if add_obj_type == 'software' and not add_form_data.get('name'):
                    error_messages.append("Software 'Name' is required.")
                    validation_passed = False
                # --- End Validation ---
                if error_messages: validation_passed = False; [st.error(msg) for msg in error_messages]

                if validation_passed and add_form_data: # Check if form data exists
                    obj_id = f"{add_obj_type}--{uuid.uuid4()}"
                    obj_args = parse_form_data_to_stix_args(add_form_data, add_obj_type)
                    obj_args['id'] = obj_id; obj_args['allow_custom'] = True
                    try:
                        # Use generic parse for all types now, relying on allow_custom
                        stix_obj = parse(obj_args, allow_custom=True)
                        if isinstance(stix_obj, dict):
                             obj_dict = stix_obj
                             obj_dict['id'] = obj_args['id']
                             obj_dict['type'] = add_obj_type
                        else:
                             obj_dict = json.loads(stix_obj.serialize())

                        st.session_state.objects.append(obj_dict)
                        # Determine label for node
                        label = obj_args.get('name', obj_args.get('value')) # Use value for SCOs if name missing
                        if obj_type == 'x509-certificate' and not label:
                            label = obj_args.get('serial_number', obj_args.get('subject', obj_id))
                        elif obj_type == 'note' and not label:
                            label = obj_args.get('abstract', obj_id) # Use abstract for note
                        elif not label:
                            label = obj_id
                        st.session_state.nodes.append({'data': { 'id': obj_id, 'label': label }})
                        st.success(f"Created {add_obj_type}: {label}")

                        # --- Generate Maps Link AFTER submission ---
                        if add_obj_type == "location":
                            lat = add_form_data.get("loc_latitude")
                            lon = add_form_data.get("loc_longitude")
                            maps_url = generate_maps_link(lat, lon)
                            if maps_url:
                                st.session_state.map_url_to_display = maps_url # Store URL to display outside form
                            else:
                                st.session_state.map_url_to_display = None
                                st.warning("Could not generate maps link: Invalid or missing Latitude/Longitude.")
                        else:
                            st.session_state.map_url_to_display = None
                        # --- End Maps Link Generation ---

                        if len(st.session_state.nodes) >= 1: st.session_state.rel_source_sel = st.session_state.nodes[0]['data']['id']
                        if len(st.session_state.nodes) >= 2: st.session_state.rel_target_sel = st.session_state.nodes[1]['data']['id']
                        else: st.session_state.rel_target_sel = None
                        st.rerun()
                    except InvalidValueError as ve: st.error(f"STIX Validation Error creating '{obj_args.get('name', obj_args.get('value', obj_id))}': {ve}")
                    except Exception as creation_e: st.error(f"Error creating STIX object '{obj_args.get('name', obj_args.get('value', obj_id))}': {creation_e}")

    # --- Create Relationship ---
    # (Keep existing Create Relationship logic)
    with st.expander("Create Relationship", expanded=False):
        eligible_nodes = [o for o in st.session_state.objects if o.get('type') not in ['relationship', 'marking-definition']]
        node_options = {o['id']: f"{o.get('name', o.get('value', o.get('id', 'ID Missing')))} ({o.get('type', 'Type Missing')})" for o in eligible_nodes}
        if not eligible_nodes or len(eligible_nodes) < 2: st.info("Add at least two graph objects first.")
        else:
            node_ids = list(node_options.keys()); default_source_index = 0; default_target_index = 0
            if st.session_state.get('rel_source_sel') in node_ids: default_source_index = node_ids.index(st.session_state.rel_source_sel)
            if len(node_ids) > 1:
                 potential_target_index = 1
                 if st.session_state.get('rel_target_sel') in node_ids: potential_target_index = node_ids.index(st.session_state.rel_target_sel)
                 if potential_target_index != default_source_index: default_target_index = potential_target_index
                 elif default_source_index == 0: default_target_index = 1
                 else: default_target_index = 0
            default_source_index = max(0, min(default_source_index, len(node_ids) - 1)); default_target_index = max(0, min(default_target_index, len(node_ids) - 1))
            def update_rel_sel(source_key, target_key):
                st.session_state.rel_source_sel = st.session_state[source_key]; st.session_state.rel_target_sel = st.session_state[target_key]
                st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None
            selected_source_id = st.selectbox("Source Object", options=node_ids, format_func=node_options.get, key="rel_source_select_widget", index=default_source_index, on_change=update_rel_sel, args=("rel_source_select_widget", "rel_target_select_widget"))
            selected_target_id = st.selectbox("Target Object", options=node_ids, format_func=node_options.get, key="rel_target_select_widget", index=default_target_index, on_change=update_rel_sel, args=("rel_source_select_widget", "rel_target_select_widget"))
            valid_rel_types_for_pair = []; rel_type_select_disabled = True; message = ""
            current_source_id = selected_source_id; current_target_id = selected_target_id
            if current_source_id and current_target_id:
                if current_source_id == current_target_id: message = "Source and Target cannot be the same."
                else:
                    source_type = get_object_type_from_id(current_source_id); target_type = get_object_type_from_id(current_target_id)
                    if source_type and target_type:
                        key = (source_type, target_type); valid_rel_types_for_pair = HARDCODED_VALID_RELATIONSHIPS.get(key, [])
                        if valid_rel_types_for_pair: rel_type_select_disabled = False
                        else: message = f"No valid relationship types for {source_type} -> {target_type}."
                    else: message = "Could not determine object types."
            if message and rel_type_select_disabled and current_source_id != current_target_id: st.warning(message)
            with st.form("create_relationship_submit_form", clear_on_submit=True):
                selected_rel_type = st.selectbox("Relationship Type", options=valid_rel_types_for_pair, disabled=rel_type_select_disabled, key="rel_type_select_in_form", index=0 if valid_rel_types_for_pair else None)
                rel_description = st.text_area("Relationship Description (Optional)", key="rel_desc_input_in_form")
                create_rel_button = st.form_submit_button("Create Relationship", disabled=rel_type_select_disabled)
                if create_rel_button:
                    form_source_id = st.session_state.rel_source_select_widget; form_target_id = st.session_state.rel_target_select_widget
                    form_rel_type = st.session_state.rel_type_select_in_form; form_rel_desc = st.session_state.rel_desc_input_in_form
                    if form_source_id and form_target_id and form_source_id != form_target_id and form_rel_type:
                        rel_id = f"relationship--{uuid.uuid4()}"
                        rel = {'type': 'relationship', 'id': rel_id, 'spec_version': '2.1', 'relationship_type': form_rel_type, 'source_ref': form_source_id, 'target_ref': form_target_id}
                        if form_rel_desc: rel['description'] = form_rel_desc
                        st.session_state.objects.append(rel)
                        st.session_state.edges.append({'data': {'id': rel_id, 'source': form_source_id, 'target': form_target_id, 'label': form_rel_type}})
                        st.success(f"Created relationship '{form_rel_type}'")
                        st.rerun()
                    else:
                         if not form_rel_type: st.error("Cannot create relationship: No valid type.")
                         elif form_source_id == form_target_id: st.error("Cannot create relationship: Source/Target same.")
                         else: st.error("Cannot create relationship. Check selections.")

    # --- Edit Object Form ---
    with st.expander("Edit Selected Object", expanded=(st.session_state.editing_object_id is not None)):
        if st.session_state.editing_object_id:
            object_to_edit = next((o for o in st.session_state.objects if o.get('id') == st.session_state.editing_object_id), None)
            if object_to_edit:
                edit_obj_type = object_to_edit.get('type', 'unknown')
                # Use appropriate label for certs and domain names
                edit_label = object_to_edit.get('name', object_to_edit.get('value', st.session_state.editing_object_id)) # Use value for SCOs
                if edit_obj_type == 'x509-certificate':
                    edit_label = object_to_edit.get('serial_number', object_to_edit.get('subject', st.session_state.editing_object_id))
                elif edit_obj_type == 'note':
                     edit_label = object_to_edit.get('abstract', st.session_state.editing_object_id)

                st.info(f"Editing: {edit_label} ({edit_obj_type})")
                st.markdown('<div class="edit-form-container">', unsafe_allow_html=True)
                # --- Ensure Edit Form has Submit Button ---
                with st.form(f"edit_object_form_{st.session_state.editing_object_id}", clear_on_submit=False): # Keep values on submit for feedback
                    edit_form_data = generate_object_form_fields(edit_obj_type, obj_data=object_to_edit, key_prefix="edit")
                    update_obj_submit = st.form_submit_button("Update Object") # Submit button for the edit form

                    if update_obj_submit:
                        validation_passed = True; error_messages = []
                        # --- ADDED Validation ---
                        if edit_obj_type == 'domain-name' and not edit_form_data.get('domain_value'):
                            error_messages.append("Domain Name 'Value' is required.")
                            validation_passed = False
                        if edit_obj_type == 'note' and not edit_form_data.get('note_content'):
                            error_messages.append("Note 'Content' is required.")
                            validation_passed = False
                        if edit_obj_type == 'note' and not edit_form_data.get('note_object_refs_str'):
                            error_messages.append("Note 'Object Refs' are required.")
                            validation_passed = False
                        if edit_obj_type == 'report' and not edit_form_data.get('name'):
                            error_messages.append("Report 'Name' is required.")
                            validation_passed = False
                        if edit_obj_type == 'report' and not edit_form_data.get('rep_report_types'):
                            error_messages.append("Report 'Report Types' are required.")
                            validation_passed = False
                        if edit_obj_type == 'report' and (not edit_form_data.get('published_date') or not edit_form_data.get('published_time')):
                            error_messages.append("Report 'Published Date/Time' is required.")
                            validation_passed = False
                        if edit_obj_type == 'report' and not edit_form_data.get('rep_object_refs_str'):
                            error_messages.append("Report 'Object Refs' are required.")
                            validation_passed = False
                        if edit_obj_type == 'software' and not edit_form_data.get('name'):
                            error_messages.append("Software 'Name' is required.")
                            validation_passed = False
                        # --- End Validation ---
                        if error_messages: validation_passed = False; [st.error(msg) for msg in error_messages]

                        if validation_passed and edit_form_data: # Check form data exists
                            try:
                                update_args = parse_form_data_to_stix_args(edit_form_data, edit_obj_type)
                                obj_index = next((i for i, o in enumerate(st.session_state.objects) if o.get('id') == st.session_state.editing_object_id), -1)
                                if obj_index != -1:
                                    original_obj = st.session_state.objects[obj_index]; updated_obj = original_obj.copy()
                                    updated_obj['modified'] = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ') # Use timezone.utc

                                    # More robust update: Apply only changed values from update_args
                                    for key, value in update_args.items():
                                        updated_obj[key] = value

                                    # Remove keys that are NOT in update_args AND are not base fields
                                    base_fields = ['id', 'type', 'spec_version', 'created', 'modified']
                                    keys_to_remove = [k for k in updated_obj if k not in update_args and k not in base_fields]
                                    for k in keys_to_remove:
                                        del updated_obj[k]

                                    # Validate the updated object using stix2.parse
                                    temp_stix_obj = parse(updated_obj, allow_custom=True)
                                    validated_obj_dict = json.loads(temp_stix_obj.serialize()) # Use validated dict

                                    st.session_state.objects[obj_index] = validated_obj_dict

                                    # Update node label in graph data if relevant field changed
                                    node_index = next((i for i, n in enumerate(st.session_state.nodes) if n['data']['id'] == st.session_state.editing_object_id), -1)
                                    if node_index != -1:
                                        new_label = validated_obj_dict.get('name', validated_obj_dict.get('value')) # Use value for SCOs
                                        if edit_obj_type == 'x509-certificate' and not new_label:
                                            new_label = validated_obj_dict.get('serial_number', validated_obj_dict.get('subject', st.session_state.editing_object_id))
                                        elif edit_obj_type == 'note' and not new_label:
                                             new_label = validated_obj_dict.get('abstract', st.session_state.editing_object_id)
                                        elif not new_label:
                                            new_label = st.session_state.editing_object_id # Fallback to ID
                                        st.session_state.nodes[node_index]['data']['label'] = new_label

                                    st.success(f"Updated object: {st.session_state.editing_object_id}")

                                    # --- Generate Maps Link AFTER submission ---
                                    if edit_obj_type == "location":
                                        lat = edit_form_data.get("loc_latitude")
                                        lon = edit_form_data.get("loc_longitude")
                                        maps_url = generate_maps_link(lat, lon)
                                        st.session_state.map_url_to_display = maps_url # Store URL
                                        if not maps_url:
                                            st.warning("Could not generate maps link: Invalid or missing Latitude/Longitude.")
                                    else:
                                         st.session_state.map_url_to_display = None
                                    # --- End Maps Link Generation ---

                                    st.rerun() # Rerun to reflect changes and potentially show map link
                                else: st.error("Error: Could not find object in state to update.")
                            except InvalidValueError as ve: st.error(f"STIX Validation Error updating object: {ve}")
                            except Exception as update_e: st.error(f"Error updating object: {update_e}")
                st.markdown('</div>', unsafe_allow_html=True)
            else: st.warning("Selected object not found."); st.session_state.editing_object_id = None
        else: st.info("Select a single node in the graph to edit its properties.")

    # --- Edit Relationship Form ---
    # (Keep existing Edit Relationship logic)
    with st.expander("Edit Selected Relationship", expanded=(st.session_state.editing_relationship_id is not None)):
        if st.session_state.editing_relationship_id:
            rel_to_edit = next((o for o in st.session_state.objects if o.get('id') == st.session_state.editing_relationship_id), None)
            if rel_to_edit and rel_to_edit.get('type') == 'relationship':
                source_ref = rel_to_edit.get('source_ref'); target_ref = rel_to_edit.get('target_ref')
                current_rel_type = rel_to_edit.get('relationship_type'); current_desc = rel_to_edit.get('description', '')
                source_obj = next((o for o in st.session_state.objects if o.get('id') == source_ref), None)
                target_obj = next((o for o in st.session_state.objects if o.get('id') == target_ref), None)
                if source_obj and target_obj:
                    source_label = f"{source_obj.get('name', source_ref)} ({source_obj.get('type')})"
                    target_label = f"{target_obj.get('name', target_ref)} ({target_obj.get('type')})"
                    st.info(f"Editing Relationship: {source_label} -> {target_label}")
                    source_type = source_obj.get('type'); target_type = target_obj.get('type')
                    valid_rel_types = HARDCODED_VALID_RELATIONSHIPS.get((source_type, target_type), [])
                    if current_rel_type not in valid_rel_types: valid_rel_types.append(current_rel_type) # Ensure current type is selectable
                    rel_type_index = valid_rel_types.index(current_rel_type) if current_rel_type in valid_rel_types else 0
                    st.markdown('<div class="edit-rel-form-container">', unsafe_allow_html=True)
                    with st.form(f"edit_relationship_form_{st.session_state.editing_relationship_id}", clear_on_submit=False):
                        st.text_input("Source", value=source_label, disabled=True); st.text_input("Target", value=target_label, disabled=True)
                        new_rel_type = st.selectbox("Relationship Type", options=valid_rel_types, index=rel_type_index, key=f"edit_rel_type_{st.session_state.editing_relationship_id}", disabled=not valid_rel_types)
                        new_desc = st.text_area("Description", value=current_desc, key=f"edit_rel_desc_{st.session_state.editing_relationship_id}")
                        update_rel_submit = st.form_submit_button("Update Relationship") # Submit button
                        if update_rel_submit:
                            try:
                                rel_obj_index = next((i for i, o in enumerate(st.session_state.objects) if o.get('id') == st.session_state.editing_relationship_id), -1)
                                edge_index = next((i for i, e in enumerate(st.session_state.edges) if e['data']['id'] == st.session_state.editing_relationship_id), -1)
                                if rel_obj_index != -1 and edge_index != -1:
                                    updated_rel_obj = st.session_state.objects[rel_obj_index].copy()
                                    updated_rel_obj['relationship_type'] = new_rel_type
                                    if new_desc: updated_rel_obj['description'] = new_desc
                                    elif 'description' in updated_rel_obj: del updated_rel_obj['description']
                                    updated_rel_obj['modified'] = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ') # Use timezone.utc
                                    st.session_state.objects[rel_obj_index] = updated_rel_obj
                                    st.session_state.edges[edge_index]['data']['label'] = new_rel_type
                                    st.success(f"Updated relationship: {st.session_state.editing_relationship_id}")
                                    st.rerun()
                                else: st.error("Error: Could not find relationship object or edge in state.")
                            except Exception as update_e: st.error(f"Error updating relationship: {update_e}")
                    st.markdown('</div>', unsafe_allow_html=True)
                else: st.warning("Could not find source or target object."); st.session_state.editing_relationship_id = None
            else: st.warning("Selected element is not a relationship or not found."); st.session_state.editing_relationship_id = None
        else: st.info("Select a single edge (relationship) in the graph to edit its properties.")

    # --- Remove Selected Element ---
    # (Keep existing Remove logic)
    with st.expander("Remove Selected Elements", expanded=False):
        elements_to_remove_ids = []
        current_selection = st.session_state.get('current_selection')
        if current_selection and isinstance(current_selection, dict):
            selected_nodes_data = current_selection.get("nodes", [])
            selected_edges_data = current_selection.get("edges", [])
            if selected_nodes_data:
                if selected_nodes_data and isinstance(selected_nodes_data[0], dict): elements_to_remove_ids.extend([node['id'] for node in selected_nodes_data])
                else: elements_to_remove_ids.extend(selected_nodes_data)
            if selected_edges_data:
                if selected_edges_data and isinstance(selected_edges_data[0], dict): elements_to_remove_ids.extend([edge['id'] for edge in selected_edges_data])
                else: elements_to_remove_ids.extend(selected_edges_data)
        if elements_to_remove_ids:
            st.write("Currently selected:")
            for elem_id in elements_to_remove_ids[:5]:
                 obj = next((o for o in st.session_state.objects if o.get('id') == elem_id), None); label = elem_id
                 if obj:
                     obj_type_display = obj.get('type', 'N/A').replace('-', ' ').title()
                     obj_name_display = obj.get('name', obj.get('value', elem_id))
                     if obj.get('type') == 'relationship': obj_name_display = f"{obj.get('source_ref', '?')} -> {obj.get('target_ref', '?')}"
                     label = f"{obj_type_display}: {obj_name_display}"
                 st.text(f"- {label}")
            if len(elements_to_remove_ids) > 5: st.text(f"... and {len(elements_to_remove_ids) - 5} more.")
            st.markdown("---")
            if st.button(f"Confirm Removal of {len(elements_to_remove_ids)} Element(s)", key="remove_button_sidebar"):
                num_removed = len(elements_to_remove_ids); ids_being_removed = set(elements_to_remove_ids)
                for elem_id in elements_to_remove_ids: remove_element(elem_id)
                st.success(f"Removed {num_removed} element(s).")
                st.session_state.current_selection = None
                if st.session_state.editing_object_id in ids_being_removed: st.session_state.editing_object_id = None
                if st.session_state.editing_relationship_id in ids_being_removed: st.session_state.editing_relationship_id = None
                st.rerun()
        else: st.info("Click elements in the graph to select them for removal.")

    # --- Export STIX bundle ---
    # (Keep existing Export logic)
    with st.expander("Export Bundle", expanded=False):
        if st.button("Generate & Download STIX 2.1 Bundle"):
            if not st.session_state.objects: st.warning("No objects to export.")
            else:
                try:
                    bundle_objects_for_export = []
                    for obj in st.session_state.objects:
                         obj_copy = obj.copy()
                         if 'spec_version' not in obj_copy: obj_copy['spec_version'] = '2.1'
                         bundle_objects_for_export.append(obj_copy)
                    bundle_to_export = Bundle(objects=bundle_objects_for_export, allow_custom=True)
                    output = bundle_to_export.serialize(pretty=True)
                    st.download_button(label="Download Bundle JSON", data=output, file_name="stix_bundle.json", mime="application/json", key="download_bundle_button")
                except Exception as e: st.error(f"Error exporting bundle: {e}")

    # --- Display Raw Objects ---
    with st.expander("Show Raw STIX Objects", expanded=False):
         if st.session_state.objects: st.json(st.session_state.objects)
         else: st.info("No objects currently in session state.")

# --- Main Area Content ---

# --- Display Map Link (if generated from last submission) ---
if st.session_state.map_url_to_display:
    st.markdown(f'<div class="maps-link-container">🗺️ [View Location on Google Maps]({st.session_state.map_url_to_display})</div>', unsafe_allow_html=True)
    st.session_state.map_url_to_display = None # Clear after displaying once

# --- Graph Section ---
# (Keep existing Graph logic)
header_cols = st.columns([0.85, 0.15])
with header_cols[0]: st.markdown("#### Graph View", unsafe_allow_html=True)
with header_cols[1]:
    fullscreen_btn_label = "Exit Full Screen" if st.session_state.fullscreen_mode else "Enter Full Screen"
    if st.button(fullscreen_btn_label, key="fullscreen_toggle"):
        st.session_state.fullscreen_mode = not st.session_state.fullscreen_mode
        st.rerun()

graph_height = "1200px" if st.session_state.fullscreen_mode else "800px"
valid_nodes = [n for n in st.session_state.nodes if isinstance(n, dict) and 'data' in n and 'id' in n['data']]
valid_edges = [e for e in st.session_state.edges if isinstance(e, dict) and 'data' in e and 'id' in e['data'] and 'source' in e['data'] and 'target' in e['data']]
valid_node_ids = {n['data']['id'] for n in valid_nodes}
valid_edges = [e for e in valid_edges if e['data']['source'] in valid_node_ids and e['data']['target'] in valid_node_ids]
elements = valid_nodes + valid_edges
# Define stylesheet using fixed light theme colors
stylesheet = [
    { 'selector': 'node', 'style': { 'label': 'data(label)', 'width': 60, 'height': 60, 'background-fit': 'contain', 'background-color': '#ddd', 'border-width': 1, 'border-color': '#555', 'font-size': '9px', 'text-valign': 'bottom', 'text-halign': 'center', 'text-margin-y': 5, 'text-wrap': 'wrap', 'text-max-width': 80, 'color': '#0e1117'}},
    { 'selector': 'edge', 'style': { 'label': 'data(label)', 'width': 2, 'line-color': '#67a3e0', 'target-arrow-color': '#67a3e0', 'target-arrow-shape': 'triangle', 'curve-style': 'bezier', 'font-size': '9px', 'color': '#555', 'text-rotation': 'autorotate', 'text-background-color': '#ffffff', 'text-background-opacity': 0, 'text-background-padding': '2px'}}, # Opacity 0 for label background
    { 'selector': ':selected', 'style': { 'border-width': 4, 'border-color': '#e74c3c', 'line-color': '#e74c3c', 'target-arrow-color': '#e74c3c', 'background-color': '#f7cac9', 'z-index': 9999 }}
]
types_in_graph = set(get_object_type_from_id(n['data']['id']) for n in valid_nodes)
for t in types_in_graph:
    if t:
        data_uri = get_icon_data_uri(t)
        if data_uri: stylesheet.append({'selector': f'node[id ^= "{t}--"]', 'style': { 'background-image': data_uri, 'background-fit': 'contain', 'background-color': 'transparent', 'background-opacity': 0 }})

if not elements: st.info("Load a STIX bundle or add objects to view the graph."); selected = None
else: selected = cytoscape(elements=elements, stylesheet=stylesheet, layout={ 'name': 'cose', 'idealEdgeLength': 150, 'nodeOverlap': 20, 'padding': 30, 'animate': False }, width="100%", height=graph_height, selection_type='multiple', key="stix_graph_final")

# --- Process Selection Update (Always run this logic) ---
# (Keep existing Selection update logic)
current_selection_in_state = st.session_state.get('current_selection')
new_editing_object_id = None; new_editing_relationship_id = None; rerun_needed_for_edit_state_change = False
if selected is not None and selected != current_selection_in_state:
    st.session_state.current_selection = selected
    selected_nodes = selected.get("nodes", []); selected_edges = selected.get("edges", [])
    if len(selected_nodes) == 1 and not selected_edges:
        node_id = selected_nodes[0]['id'] if isinstance(selected_nodes[0], dict) else selected_nodes[0]
        if node_id != st.session_state.editing_object_id: new_editing_object_id = node_id; new_editing_relationship_id = None; rerun_needed_for_edit_state_change = True
    elif len(selected_edges) == 1 and not selected_nodes:
        edge_id = selected_edges[0]['id'] if isinstance(selected_edges[0], dict) else selected_edges[0]
        if edge_id != st.session_state.editing_relationship_id: new_editing_relationship_id = edge_id; new_editing_object_id = None; rerun_needed_for_edit_state_change = True
    elif st.session_state.editing_object_id is not None or st.session_state.editing_relationship_id is not None:
        new_editing_object_id = None; new_editing_relationship_id = None; rerun_needed_for_edit_state_change = True
    if rerun_needed_for_edit_state_change or (not st.session_state.fullscreen_mode and selected != current_selection_in_state):
        st.session_state.editing_object_id = new_editing_object_id; st.session_state.editing_relationship_id = new_editing_relationship_id
        st.rerun()
elif selected is None and current_selection_in_state is not None:
     st.session_state.current_selection = None
     if st.session_state.editing_object_id is not None or st.session_state.editing_relationship_id is not None:
         st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None
         st.rerun()
     elif not st.session_state.fullscreen_mode: st.rerun()
