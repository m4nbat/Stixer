# Streamlit STIX 2.1 Visualizer and Editor
# -----------------------------------------
# Requirements:
#   pip install streamlit stix2 st-cytoscape python-dateutil
#
# Run: python -m streamlit run your_script_name.py

import streamlit as st
# Ensure necessary STIX classes are imported (or rely on generic parsing)
from stix2 import (Bundle, parse, AttackPattern, Campaign, CourseOfAction, Identity,
                   Indicator, Infrastructure, IntrusionSet, Location, Malware, Note,
                   ObservedData, Report, ThreatActor, Tool, Vulnerability, MalwareAnalysis)
from stix2.exceptions import InvalidValueError, MissingPropertiesError # Import specific error
import uuid
import json
from st_cytoscape import cytoscape
import base64
import os
import re
import io
import time # Import time for potential debugging pauses
from datetime import datetime, time as dt_time, date, timezone # Import timezone
# Ensure dateutil.parser is imported if used (it is used in _parse_stix_timestamp)
from dateutil.parser import isoparse
import urllib.parse

# --- Configuration ---
st.set_page_config(page_title="Stixer by Manb4t", layout="wide")

# --- Vocabularies & Mappings (Define BEFORE Session State) ---

# Hardcoded Relationship Rules (Keep as is)
HARDCODED_VALID_RELATIONSHIPS = {
    ('attack-pattern', 'malware'): ['delivers', 'uses'], ('attack-pattern', 'identity'): ['targets'],
    ('attack-pattern', 'location'): ['targets'], ('attack-pattern', 'vulnerability'): ['targets'],
    ('attack-pattern', 'tool'): ['uses'], ('campaign', 'intrusion-set'): ['attributed-to'],
    ('campaign', 'threat-actor'): ['attributed-to'], ('campaign', 'infrastructure'): ['compromises', 'uses'],
    ('campaign', 'location'): ['originates-from', 'targets'], ('campaign', 'identity'): ['targets'],
    ('campaign', 'vulnerability'): ['targets'], ('campaign', 'attack-pattern'): ['uses'],
    ('campaign', 'malware'): ['uses'], ('course-of-action', 'indicator'): ['investigates', 'mitigates'],
    ('course-of-action', 'attack-pattern'): ['mitigates'], ('course-of-action', 'malware'): ['mitigates'],
    ('course-of-action', 'tool'): ['mitigates'], ('course-of-action', 'vulnerability'): ['mitigates'],
    ('identity', 'location'): ['located-at'], ('indicator', 'attack-pattern'): ['indicates'],
    ('indicator', 'campaign'): ['indicates'], ('indicator', 'infrastructure'): ['indicates'],
    ('indicator', 'intrusion-set'): ['indicates'], ('indicator', 'malware'): ['indicates'],
    ('indicator', 'threat-actor'): ['indicates'], ('indicator', 'tool'): ['indicates'], ('indicator', 'email-addr'): ['indicates'],
    ('indicator', 'observed-data'): ['based-on'],
    ('infrastructure', 'infrastructure'): ['communicates-with', 'consists-of', 'controls', 'uses'],
    ('infrastructure', 'ipv4-addr'): ['communicates-with'], ('infrastructure', 'ipv6-addr'): ['communicates-with'],
    ('infrastructure', 'domain-name'): ['communicates-with'], ('infrastructure', 'url'): ['communicates-with'],
    ('infrastructure', 'observed-data'): ['consists-of'], ('infrastructure', 'malware'): ['controls', 'delivers', 'hosts'],
    ('infrastructure', 'vulnerability'): ['has'], ('infrastructure', 'tool'): ['hosts'],
    ('infrastructure', 'location'): ['located-at'], ('intrusion-set', 'threat-actor'): ['attributed-to'],
    ('intrusion-set', 'infrastructure'): ['compromises', 'hosts', 'owns', 'uses'],
    ('intrusion-set', 'location'): ['originates-from', 'targets'], ('intrusion-set', 'vulnerability'): ['targets'],
    ('intrusion-set', 'identity'): ['targets'], ('intrusion-set', 'attack-pattern'): ['uses'],
    ('intrusion-set', 'malware'): ['uses'], ('intrusion-set', 'tool'): ['uses'],
    ('malware', 'threat-actor'): ['authored-by'], ('malware', 'intrusion-set'): ['authored-by'],
    ('malware', 'infrastructure'): ['beacons-to', 'exfiltrate-to', 'targets', 'uses'],
    ('malware', 'url'): ['communicates-with'], ('malware', 'domain-name'): ['communicates-with'],
    ('malware', 'ipv6-addr'): ['communicates-with'], ('malware', 'ipv4-addr'): ['communicates-with'],
    ('malware', 'malware'): ['controls', 'downloads', 'drops', 'uses', 'variant-of'],
    ('malware', 'tool'): ['downloads', 'drops', 'uses'], ('malware', 'file'): ['downloads', 'drops'],
    ('malware', 'vulnerability'): ['exploits', 'targets'], ('malware', 'location'): ['originates-from', 'targets'],
    ('malware', 'identity'): ['targets'], ('malware', 'attack-pattern'): ['uses'],
    ('malware-analysis', 'malware'): ['characterizes', 'analysis-of', 'static-analysis-of', 'dynamic-analysis-of'],
    ('threat-actor', 'identity'): ['attributed-to', 'impersonates', 'targets'],
    ('threat-actor', 'infrastructure'): ['compromises', 'owns', 'hosts', 'uses'],
    ('threat-actor', 'location'): ['located-at', 'targets'], ('threat-actor', 'vulnerability'): ['targets'],
    ('threat-actor', 'attack-pattern'): ['uses'], ('threat-actor', 'malware'): ['uses'],
    ('threat-actor', 'tool'): ['uses'], ('tool', 'malware'): ['delivers', 'drops'],
    ('tool', 'vulnerability'): ['has', 'targets'], ('tool', 'identity'): ['targets'],
    ('tool', 'infrastructure'): ['targets'], ('tool', 'location'): ['targets'],
    ('domain-name', 'domain-name'): ['resolves-to'],
    ('domain-name', 'ipv4-addr'): ['resolves-to'],
    ('domain-name', 'ipv6-addr'): ['resolves-to'],
}

# Vocabularies
THREAT_ACTOR_TYPES_OV = ["", "activist", "competitor", "crime-syndicate", "criminal", "hacker", "insider-accidental", "insider-disgruntled", "nation-state", "sensationalist", "spy", "terrorist", "unknown"]
THREAT_ACTOR_ROLES_OV = ["", "agent", "director", "independent", "infrastructure-architect", "infrastructure-operator", "malware-author", "sponsor"]
THREAT_ACTOR_SOPHISTICATION_OV = ["", "none", "minimal", "intermediate", "advanced", "expert", "innovator", "strategic"]
ATTACK_RESOURCE_LEVEL_OV = ["", "individual", "club", "contest", "team", "organization", "government"]
ATTACK_MOTIVATION_OV = ["", "accidental", "coercion", "dominance", "ideology", "notoriety", "organizational-gain", "personal-gain", "personal-satisfaction", "revenge", "unpredictable"]
HASH_ALGO_OV = ["", "MD5", "SHA-1", "SHA-256", "SHA-512", "SHA3-256", "SHA3-512", "SSDEEP", "TLSH"]
IDENTITY_CLASS_OV = ["", "individual", "group", "system", "organization", "class", "unknown"]
INDICATOR_TYPES_OV = ["", "anomalous-activity", "anonymization", "benign", "compromised", "malicious-activity", "attribution", "unknown"]
MALWARE_TYPES_OV = ["", "adware", "backdoor", "bot", "bootkit", "ddos", "downloader", "dropper", "exploit-kit", "keylogger", "ransomware", "remote-access-trojan", "resource-exploitation", "rootkit", "screen-capture", "spyware", "trojan", "unknown", "virus", "webshell", "wiper", "worm"]
REPORT_TYPES_OV = ["", "attack-pattern", "campaign", "identity", "indicator", "intrusion-set", "malware", "observed-data", "threat-actor", "threat-report", "tool", "vulnerability"]
TOOL_TYPES_OV = ["", "denial-of-service", "exploitation", "information-gathering", "network-capture", "penetration-testing", "remote-access", "vulnerability-scanning", "unknown"]
REGION_OV = ["", "africa", "eastern-africa", "middle-africa", "northern-africa", "southern-africa", "western-africa", "americas", "latin-america-caribbean", "south-america", "caribbean", "central-america", "northern-america", "asia", "central-asia", "eastern-asia", "southern-asia", "south-eastern-asia", "western-asia", "europe", "eastern-europe", "northern-europe", "southern-europe", "western-europe", "oceania", "antarctica", "australia-new-zealand", "melanesia", "micronesia", "polynesia"]
INDUSTRY_SECTOR_OV = ["", "agriculture", "aerospace", "automotive", "communications", "construction", "defence", "education", "energy", "entertainment", "financial-services", "government-national", "government-regional", "government-local", "government-public-services", "healthcare", "hospitality-leisure", "infrastructure", "insurance", "manufacturing", "mining", "non-profit", "pharmaceuticals", "retail", "technology", "telecommunications", "transportation", "utilities"]
LOCKHEED_MARTIN_PHASES_STR = "Reconnaissance, Weaponization, Delivery, Exploitation, Installation, Command and Control (C2), Actions on Objectives"
KILL_CHAIN_NAMES = ["", "lockheed-martin-cyber-kill-chain", "mitre-attack", "unified-kill-chain", "custom"]
KILL_CHAIN_PHASES = {
    "lockheed-martin-cyber-kill-chain": ["reconnaissance", "weaponization", "delivery", "exploitation", "installation", "command-and-control", "actions-on-objectives"],
    "mitre-attack": ["reconnaissance", "resource-development", "initial-access", "execution", "persistence", "privilege-escalation", "defense-evasion", "credential-access", "discovery", "lateral-movement", "collection", "command-and-control", "exfiltration", "impact"],
    "unified-kill-chain": ["in", "through", "out"]
}
INFRASTRUCTURE_TYPES_OV = ["", "amplification", "anonymization", "botnet", "command-and-control", "exfiltration", "hosting-malware", "hosting-target-lists", "phishing", "reconnaissance", "staging", "unknown"]
PATTERN_TYPES_OV = ["stix", "pcre", "sigma", "snort", "suricata", "yara"] # For Indicator
MALWARE_AV_RESULT_OV = ["", "malicious", "suspicious", "benign", "unknown"] # For Malware Analysis

# Define Object Types List (Add malware-analysis)
source_types = set(k[0] for k in HARDCODED_VALID_RELATIONSHIPS.keys())
target_types = set(k[1] for k in HARDCODED_VALID_RELATIONSHIPS.keys())
hardcoded_types = source_types.union(target_types)
standard_types = [
    'attack-pattern','campaign','course-of-action','identity',
    'indicator','infrastructure','intrusion-set','malware','malware-analysis', # Added malware-analysis
    'observed-data','report','threat-actor','tool','vulnerability',
    'location','note','marking-definition', 'language-content',
    'directory', 'domain-name', 'email-addr', 'email-message', 'file',
    'ipv4-addr', 'ipv6-addr', 'mac-addr', 'mutex', 'network-traffic',
    'process', 'software', 'url', 'user-account', 'windows-registry-key',
    'x509-certificate'
]
ALL_OBJECT_TYPES = sorted(list(set(standard_types).union(hardcoded_types)))

# Map STIX types to their respective classes (SCOs handled via dict)
TYPE_TO_CLASS_MAPPING = {
    'attack-pattern': AttackPattern, 'campaign': Campaign, 'course-of-action': CourseOfAction,
    'identity': Identity, 'indicator': Indicator, 'infrastructure': Infrastructure,
    'intrusion-set': IntrusionSet, 'location': Location, 'malware': Malware, 'note': Note,
    'observed-data': ObservedData, 'report': Report, 'threat-actor': ThreatActor,
    'tool': Tool, 'vulnerability': Vulnerability, 'malware-analysis': MalwareAnalysis # Added MA
    # SCOs like x509-certificate, domain-name, software will use generic parsing with allow_custom=True
}

# --- Session State Initialization ---
if 'objects' not in st.session_state: st.session_state.objects = []
if 'nodes' not in st.session_state: st.session_state.nodes = []
if 'edges' not in st.session_state: st.session_state.edges = []
if 'current_selection' not in st.session_state: st.session_state.current_selection = None
if 'rel_source_sel' not in st.session_state: st.session_state.rel_source_sel = None
if 'rel_target_sel' not in st.session_state: st.session_state.rel_target_sel = None
if 'add_form_selected_type' not in st.session_state:
    st.session_state.add_form_selected_type = ALL_OBJECT_TYPES[0] if ALL_OBJECT_TYPES else None
if 'uploaded_file_state' not in st.session_state: st.session_state.uploaded_file_state = None
if 'fullscreen_mode' not in st.session_state: st.session_state.fullscreen_mode = False
if 'editing_object_id' not in st.session_state: st.session_state.editing_object_id = None
if 'editing_relationship_id' not in st.session_state: st.session_state.editing_relationship_id = None
# State to store generated map URL to display after form submission
if 'map_url_to_display' not in st.session_state: st.session_state.map_url_to_display = None


# --- Styling (Simplified - Light Theme Only) ---
# (Keep existing styles)
st.markdown("""
<style>
/* Basic Light Theme Styles */
body { background-color: #f0f0f0; color: #0e1117; }
.stApp { background-color: #f0f0f0; }
.block-container { padding: 1rem 2rem; }
.sidebar .sidebar-content { background-color: #f0f0f0; }
.stTextArea textarea { font-family: monospace; height: 100px; }
.stCytoscape > div { width: 100%; height: 100%; border: 1px solid #cccccc; border-radius: 5px; background-color: #ffffff; }
.selected-node-main { border: 1px solid #cccccc; border-radius: 4px; padding: 8px; margin-bottom: 8px; background-color: #f8f9fa; font-size: 0.9em; word-wrap: break-word; color: #0e1117; }
.selected-node-label-main { font-weight: bold; color: #555; margin-right: 5px; }
.streamlit-expanderHeader { font-size: 1.0em; color: #0e1117; padding-top: 3px; padding-bottom: 3px; }
.streamlit-expander { border: 1px solid #cccccc; border-radius: 5px; background-color: #ffffff; }
.edit-form-container { border: 1px solid #007bff; border-radius: 5px; padding: 15px; margin-top: 5px; background-color: #e7f3ff; }
.edit-form-container .stButton button { background-color: #28a745; color: white; border-color: #28a745; }
.edit-form-container .stButton button:hover { background-color: #218838; border-color: #1e7e34; color: white; }
.edit-rel-form-container { border: 1px solid #ffc107; border-radius: 5px; padding: 15px; margin-top: 5px; background-color: #fff8e1; }
.edit-rel-form-container .stButton button { background-color: #ffc107; color: #212529; border-color: #ffc107; }
.edit-rel-form-container .stButton button:hover { background-color: #e0a800; border-color: #d39e00; color: #212529; }
.stForm h3 { margin-top: 1rem; margin-bottom: 0.5rem; color: #0e1117; }
.stForm [data-testid="column"] { padding-left: 5px; padding-right: 5px; }
.maps-link-container { margin-top: 10px; padding: 10px; background-color: #e9ecef; border: 1px dashed #cccccc; border-radius: 5px; }
.maps-link-container a { color: #007bff; }
.graph-header { margin-bottom: 0.5rem; }
.graph-header h4 { margin-bottom: 0; margin-top: 0; padding-bottom: 0; font-size: 1.2em; color: #0e1117; }
.graph-header .stButton > button { padding-top: 0.25rem; padding-bottom: 0.25rem; font-size: 0.8em; }
/* General Widget Styling */
.stTextInput > div > div > input, .stTextArea > div > div > textarea, .stSelectbox > div > div > div, .stMultiselect > div > div > div, .stDateInput > div > div > div, .stTimeInput > div > div > div, .stNumberInput > div > div > input { background-color: #ffffff; color: #0e1117; border: 1px solid #ced4da; border-radius: 5px; }
div[data-baseweb="popover"] ul { background-color: #ffffff; }
div[data-baseweb="popover"] ul li { color: #0e1117; }
div[data-baseweb="popover"] ul li:hover { background-color: #007bff; color: #ffffff; }
.stButton > button, .stDownloadButton > button { border: 1px solid #007bff; background-color: #007bff; color: #ffffff; border-radius: 5px; }
.stButton > button:hover, .stDownloadButton > button:hover { border: 1px solid #0056b3; background-color: #0056b3; color: #ffffff; }

/* Style the Streamlit header bar */
[data-testid="stHeader"] {
    background-color: #f0f0f0 !important; /* Match sidebar background, !important might be needed */
    border-bottom: 1px solid #cccccc; /* Add a subtle border */
}
/* Adjust main content padding if header looks too close */
/* section.main .block-container {
    padding-top: 5rem;
} */

</style>
""", unsafe_allow_html=True)


# --- Helper Functions ---

def get_object_type_from_id(stix_id):
    """Extracts the object type from a STIX ID."""
    if isinstance(stix_id, str) and '--' in stix_id:
        return stix_id.split('--')[0]
    return None

def remove_element(element_id):
    """Removes an element and its connected relationships from session state."""
    original_obj_count = len(st.session_state.objects)
    obj_to_remove = next((o for o in st.session_state.objects if o['id'] == element_id), None)
    if not obj_to_remove: return
    rels_to_remove_ids = set()
    if obj_to_remove['type'] == 'relationship':
        rels_to_remove_ids.add(element_id)
        st.session_state.edges = [e for e in st.session_state.edges if e['data']['id'] != element_id]
    else:
        connected_rels = [o['id'] for o in st.session_state.objects
                          if o.get('type') == 'relationship' and
                             (o.get('source_ref') == element_id or o.get('target_ref') == element_id)]
        rels_to_remove_ids.update(connected_rels)
        st.session_state.nodes = [n for n in st.session_state.nodes if n['data']['id'] != element_id]
        st.session_state.edges = [e for e in st.session_state.edges if e['data']['id'] not in rels_to_remove_ids]
    st.session_state.objects = [o for o in st.session_state.objects if o['id'] != element_id]
    if obj_to_remove['type'] != 'relationship' and rels_to_remove_ids:
         st.session_state.objects = [o for o in st.session_state.objects if o['id'] not in rels_to_remove_ids]

@st.cache_data
def get_icon_data_uri(obj_type):
    """Loads icon file, encodes it, and returns a data URI string."""
    try: script_dir = os.path.dirname(__file__)
    except NameError: script_dir = os.getcwd()
    icon_file = os.path.join(script_dir, 'icons', f"{obj_type}-round-flat-300-dpi.png")
    fallback_icon_file = os.path.join(script_dir, 'icons', "unknown-round-flat-300-dpi.png")
    icon_to_load = icon_file if os.path.exists(icon_file) else fallback_icon_file
    if not os.path.exists(icon_to_load): return None
    try:
        with open(icon_to_load, 'rb') as img_f: img_bytes = img_f.read()
        b64 = base64.b64encode(img_bytes).decode('utf-8')
        return f"url('data:image/png;base64,{b64}')"
    except Exception as e: print(f"Error reading icon file {icon_to_load}: {e}"); return None

# --- Function to load and encode sidebar logo ---
@st.cache_data
def get_sidebar_logo_uri():
    """Loads the manbat.png logo, encodes it, and returns a data URI string."""
    try: script_dir = os.path.dirname(__file__)
    except NameError: script_dir = os.getcwd() # Fallback for environments where __file__ is not defined
    logo_path = os.path.join(script_dir, 'icons', 'manbat.png')
    if not os.path.exists(logo_path):
        print(f"Warning: Logo file not found at {logo_path}")
        return None
    try:
        with open(logo_path, "rb") as f:
            logo_bytes = f.read()
        b64_logo = base64.b64encode(logo_bytes).decode('utf-8')
        return f"data:image/png;base64,{b64_logo}"
    except Exception as e:
        print(f"Error reading or encoding logo file {logo_path}: {e}")
        return None
# --- END NEW FUNCTION ---


# --- Form Generation and Parsing Helpers ---

def _get_default(data, key, default=""):
    """Safely gets a value from a dictionary, returning a default if None or missing."""
    val = data.get(key, default)
    return val if val is not None else default

def _list_to_text(data, key):
    """Converts a list found at data[key] to a newline-separated string."""
    return "\n".join(data.get(key, []))

def _kill_chain_to_text(data, key):
    """Converts kill_chain_phases list to a newline-separated string."""
    phases = data.get(key, [])
    return "\n".join([f"{p.get('kill_chain_name', '')}:{p.get('phase_name', '')}" for p in phases])

def _hashes_to_text(hashes_dict):
    """Converts a hashes dictionary {algo: hash} to a multiline string 'ALGO:hash'."""
    if not hashes_dict or not isinstance(hashes_dict, dict): return ""
    return "\n".join([f"{algo}:{h}" for algo, h in hashes_dict.items()])

def _ext_ref_hashes_to_text(ext_refs):
    """Extracts hashes from the first external reference and converts to multiline string."""
    if not ext_refs or not isinstance(ext_refs, list) or not ext_refs[0].get("hashes"): return ""
    hashes_dict = ext_refs[0].get("hashes", {})
    return "\n".join([f"{algo}:{h}" for algo, h in hashes_dict.items()])

def _parse_stix_timestamp(timestamp_str):
    """Parses a STIX timestamp string into date and time objects (UTC)."""
    if not timestamp_str or not isinstance(timestamp_str, str): return None, None
    try:
        # Use isoparse for robust ISO 8601 parsing
        dt_obj = isoparse(timestamp_str)
        # Ensure timezone is UTC
        if dt_obj.tzinfo is None:
            dt_obj = dt_obj.replace(tzinfo=timezone.utc)
        else:
            dt_obj = dt_obj.astimezone(timezone.utc)
        # Return date and time (naive, as UTC is handled)
        return dt_obj.date(), dt_obj.time().replace(tzinfo=None)
    except ValueError:
        # Handle cases where parsing fails
        return None, None

def generate_maps_link(lat, lon):
    """Generates a Google Maps link from latitude and longitude."""
    try:
        lat_f = float(lat); lon_f = float(lon)
        # Basic Google Maps URL format
        return f"https://www.google.com/maps?q={lat_f},{lon_f}"
    except (ValueError, TypeError, AttributeError):
        # Handle invalid input gracefully
        return None

def generate_object_form_fields(obj_type, obj_data=None, key_prefix="add"):
    """
    Generates Streamlit form widgets dynamically based on the STIX object type.

    Args:
        obj_type (str): The type of the STIX object (e.g., 'attack-pattern').
        obj_data (dict, optional): Existing data for the object (used for editing). Defaults to None.
        key_prefix (str, optional): Prefix for widget keys to ensure uniqueness ('add' or 'edit'). Defaults to "add".

    Returns:
        dict: A dictionary containing the values entered into the generated form fields.
              The keys correspond to the STIX property names or derived form field names.
    """
    data = obj_data or {} # Use provided data or an empty dict
    form_values = {} # Dictionary to store the input values

    # --- Handle objects without standard 'name' or 'description' ---
    # Certain SCOs or specific SDOs might use different primary identifiers.
    if obj_type in ['x509-certificate', 'domain-name', 'note', 'malware-analysis']: # Added malware-analysis
        # Determine a suitable display label based on available fields
        display_label = _get_default(data, 'value', # domain-name
                        _get_default(data, 'serial_number', # x509-certificate
                        _get_default(data, 'subject', # x509-certificate fallback
                        _get_default(data, 'abstract', # note
                        _get_default(data, 'product', # malware-analysis
                        f"New {obj_type}"))))) # Default label
        st.markdown(f"**{obj_type.replace('-', ' ').title()}:** {display_label}")
        # Show name/desc specifically for Software, even though it's in this list (it has standard name/desc)
        if obj_type == 'software':
            form_values['name'] = st.text_input("Name (Required)", value=_get_default(data, 'name'), key=f"{key_prefix}_{obj_type}_name")
            form_values['description'] = st.text_area("Description", value=_get_default(data, 'description'), key=f"{key_prefix}_{obj_type}_desc")
    else: # SDOs/SCOs that typically have name/description
        # Determine if 'name' is mandatory for this object type
        name_required = obj_type in [
            'intrusion-set', 'threat-actor', 'malware', 'tool', 'vulnerability',
            'campaign', 'identity', 'location', 'course-of-action',
            'attack-pattern', 'report', 'software'
            ]
        name_label = "Name (Required)" if name_required else "Name / Value"
        # Use 'value' as default for SCOs if 'name' is missing
        default_name_or_value = _get_default(data, 'name', _get_default(data, 'value'))
        form_values['name'] = st.text_input(name_label, value=default_name_or_value, key=f"{key_prefix}_{obj_type}_name")
        form_values['description'] = st.text_area("Description", value=_get_default(data, 'description'), key=f"{key_prefix}_{obj_type}_desc")

    st.subheader(f"{obj_type.replace('-', ' ').title()} Properties")

    # --- Helper function for Date/Time Input ---
    def datetime_input(label, data_key, required=False):
        """Generates date and time input widgets for a STIX timestamp field."""
        st.markdown(f"**{label}{' (Required)' if required else ''}**")
        # Parse existing timestamp if available
        default_date, default_time = _parse_stix_timestamp(data.get(data_key))
        col1, col2 = st.columns(2)
        with col1:
            # Date input
            form_values[f'{data_key}_date'] = st.date_input("Date", value=default_date, key=f"{key_prefix}_{data_key}_date")
        with col2:
            # Time input (UTC), default to midnight if no time provided
            form_values[f'{data_key}_time'] = st.time_input("Time (UTC)", value=default_time or dt_time(0, 0), key=f"{key_prefix}_{data_key}_time", step=3600) # Step by hour

    # --- Helper function for Kill Chain Phase Input ---
    def kill_chain_input(data_key_prefix):
        """Generates widgets for selecting or defining a single kill chain phase."""
        st.markdown("**Kill Chain Phase (Optional - Select One)**")
        # Define unique keys for widgets within this function call
        kc_name_widget_key = f"{key_prefix}_{data_key_prefix}_kc_name_widget"
        custom_kc_name_widget_key = f"{key_prefix}_{data_key_prefix}_custom_kc_name_input"
        custom_phase_name_widget_key = f"{key_prefix}_{data_key_prefix}_custom_phase_name_input"
        phase_name_select_key = f"{key_prefix}_{data_key_prefix}_phase_name_select"

        # Determine default values based on existing data
        default_kc_name = ""; default_phase_name = ""; is_custom_default = False
        if data.get('kill_chain_phases') and isinstance(data['kill_chain_phases'], list) and data['kill_chain_phases']:
            first_phase = data['kill_chain_phases'][0] # Only handle the first phase for simplicity
            default_kc_name = first_phase.get('kill_chain_name', "")
            default_phase_name = first_phase.get('phase_name', "")
            # Check if the default name is one of the standard ones or custom
            if default_kc_name not in KILL_CHAIN_NAMES:
                is_custom_default = True
            elif not default_kc_name: # Handle empty string case
                default_kc_name = ""

        # Determine the index for the kill chain name selectbox
        kc_name_index = KILL_CHAIN_NAMES.index("custom") if is_custom_default else (KILL_CHAIN_NAMES.index(default_kc_name) if default_kc_name in KILL_CHAIN_NAMES else 0)

        # Kill Chain Name Selection (Standard or Custom)
        selected_kc_name = st.selectbox("Kill Chain Name", options=KILL_CHAIN_NAMES, index=kc_name_index, key=kc_name_widget_key, help="Select a standard kill chain or 'custom'.")
        form_values[f'{data_key_prefix}_kc_name'] = selected_kc_name # Store the selection ('', 'lockheed...', 'custom')

        # Conditional widgets based on kill chain name selection
        if selected_kc_name == "custom":
            # Input fields for custom kill chain and phase names
            custom_kc_val = default_kc_name if is_custom_default else ""
            custom_phase_val = default_phase_name if is_custom_default else ""
            form_values[f'{data_key_prefix}_custom_kc_name'] = st.text_input("Custom Kill Chain Name", value=custom_kc_val, key=custom_kc_name_widget_key, help="Enter custom name (lowercase, hyphenated).")
            form_values[f'{data_key_prefix}_phase_name'] = st.text_input("Custom Phase Name", value=custom_phase_val, key=custom_phase_name_widget_key, help="Enter custom phase name (lowercase, hyphenated).")
        elif selected_kc_name: # A standard kill chain name was selected
            available_phases = KILL_CHAIN_PHASES.get(selected_kc_name, [])
            phase_default_val = ""
            # Set default phase if the existing data matches the selected kill chain
            if data.get('kill_chain_phases') and data['kill_chain_phases']:
                 first_phase = data['kill_chain_phases'][0]
                 if first_phase.get('kill_chain_name') == selected_kc_name:
                     phase_default_val = first_phase.get('phase_name', "")
            # Determine index for the phase name selectbox
            phase_name_index = available_phases.index(phase_default_val) if phase_default_val in available_phases else 0
            form_values[f'{data_key_prefix}_phase_name'] = st.selectbox("Phase Name", options=available_phases, index=phase_name_index, key=phase_name_select_key)
        else: # No kill chain selected
            form_values[f'{data_key_prefix}_phase_name'] = None # No phase can be selected

    # --- Type Specific Fields ---
    # Generate fields based on the object type
    if obj_type == 'attack-pattern':
        form_values['ap_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_ap_aliases")
        kill_chain_input("ap") # Add kill chain input specific to attack-pattern
    elif obj_type == 'campaign': # UPDATED
        form_values['c_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_c_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['c_objective'] = st.text_area("Objective", value=_get_default(data, 'objective'), key=f"{key_prefix}_c_objective")
    elif obj_type == 'course-of-action':
        # Name and Description handled by generic fields at the top
        pass # No other specific required/optional fields in STIX 2.1 for CoA itself
    elif obj_type == 'identity':
        form_values['id_identity_class'] = st.selectbox("Identity Class", options=IDENTITY_CLASS_OV, index=IDENTITY_CLASS_OV.index(_get_default(data, 'identity_class', "")), key=f"{key_prefix}_id_class")
        form_values['id_sectors'] = st.multiselect("Sectors", options=INDUSTRY_SECTOR_OV[1:], default=data.get('sectors', []), key=f"{key_prefix}_id_sectors")
        form_values['id_contact_information'] = st.text_input("Contact Information", value=_get_default(data, 'contact_information'), key=f"{key_prefix}_id_contact")
    elif obj_type == 'indicator': # UPDATED
         # --- Filter default indicator types ---
         standard_options = INDICATOR_TYPES_OV[1:] # Options allowed by the standard list
         current_types = data.get('indicator_types', []) # Get types from the object data
         # Keep only the types from the object that are also in the standard options list
         valid_defaults = [t for t in current_types if t in standard_options]
         # Identify any non-standard types present in the object's data
         non_standard_types = [t for t in current_types if t not in standard_options]
         # --- End filtering ---

         # Use the filtered 'valid_defaults' for the multiselect default
         form_values['ind_indicator_types'] = st.multiselect(
             "Indicator Types",
             options=standard_options,
             default=valid_defaults, # Pass the filtered list here
             key=f"{key_prefix}_ind_types"
         )

         # --- Display warning if non-standard types were found ---
         if non_standard_types:
             st.warning(f"Note: This object contains non-standard Indicator Types: `{'`, `'.join(non_standard_types)}`. Please update to standard values from the list above.")
         # --- End warning ---

         form_values['ind_pattern_type'] = st.selectbox("Pattern Type (Required)", options=PATTERN_TYPES_OV, index=PATTERN_TYPES_OV.index(_get_default(data, 'pattern_type', "stix")), key=f"{key_prefix}_ind_patt_type")
         form_values['ind_pattern'] = st.text_area("Pattern (Required)", value=_get_default(data, 'pattern'), key=f"{key_prefix}_ind_pattern")
         datetime_input("Valid From", "valid_from", required=True); datetime_input("Valid Until", "valid_until")
         kill_chain_input("ind") # Add kill chain input specific to indicator
    elif obj_type == 'infrastructure': # UPDATED
        form_values['inf_infrastructure_types'] = st.multiselect("Infrastructure Types", options=INFRASTRUCTURE_TYPES_OV[1:], default=data.get('infrastructure_types', []), key=f"{key_prefix}_inf_types")
        form_values['inf_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_inf_aliases")
        kill_chain_input("inf") # Add kill chain input specific to infrastructure
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
    elif obj_type == 'intrusion-set': # UPDATED
        form_values['is_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_is_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['is_goals_str'] = st.text_area("Goals (one per line)", value=_list_to_text(data, 'goals'), key=f"{key_prefix}_is_goals")
        form_values['is_resource_level'] = st.selectbox("Resource Level", options=ATTACK_RESOURCE_LEVEL_OV, index=ATTACK_RESOURCE_LEVEL_OV.index(_get_default(data, 'resource_level', "")), key=f"{key_prefix}_is_resource_level")
        form_values['is_primary_motivation'] = st.selectbox("Primary Motivation", options=ATTACK_MOTIVATION_OV, index=ATTACK_MOTIVATION_OV.index(_get_default(data, 'primary_motivation', "")), key=f"{key_prefix}_is_primary_motivation")
        form_values['is_secondary_motivations'] = st.multiselect("Secondary Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('secondary_motivations', []), key=f"{key_prefix}_is_secondary_motivations")
    elif obj_type == 'location':
         form_values['loc_region'] = st.selectbox("Region", options=REGION_OV, index=REGION_OV.index(_get_default(data, 'region', "")), key=f"{key_prefix}_loc_region")
         form_values['loc_country'] = st.text_input("Country (ISO 3166-1 alpha-2)", value=_get_default(data, 'country'), key=f"{key_prefix}_loc_country", help="Use 2-letter country code (e.g., US, GB)")
         form_values['loc_administrative_area'] = st.text_input("Administrative Area (e.g., state)", value=_get_default(data, 'administrative_area'), key=f"{key_prefix}_loc_admin_area")
         form_values['loc_city'] = st.text_input("City", value=_get_default(data, 'city'), key=f"{key_prefix}_loc_city")
         form_values['loc_street_address'] = st.text_input("Street Address", value=_get_default(data, 'street_address'), key=f"{key_prefix}_loc_street")
         form_values['loc_postal_code'] = st.text_input("Postal Code", value=_get_default(data, 'postal_code'), key=f"{key_prefix}_loc_postal")
         # Use number_input for lat/lon/precision for better validation
         form_values['loc_latitude'] = st.number_input("Latitude", value=data.get('latitude'), format="%.6f", key=f"{key_prefix}_loc_lat", help="e.g., 48.8584")
         form_values['loc_longitude'] = st.number_input("Longitude", value=data.get('longitude'), format="%.6f", key=f"{key_prefix}_loc_lon", help="e.g., 2.2945")
         form_values['loc_precision'] = st.number_input("Precision (meters)", value=data.get('precision'), min_value=0.0, format="%.1f", key=f"{key_prefix}_loc_prec")
    elif obj_type == 'malware': # UPDATED
         form_values['mal_malware_types'] = st.multiselect("Malware Types", options=MALWARE_TYPES_OV[1:], default=data.get('malware_types', []), key=f"{key_prefix}_mal_types")
         form_values['mal_is_family'] = st.checkbox("Is Family?", value=data.get('is_family', False), key=f"{key_prefix}_mal_is_family")
         form_values['mal_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_mal_aliases")
         kill_chain_input("mal") # Add kill chain input specific to malware
         datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
         form_values['mal_os_execution_envs_str'] = st.text_area("OS Execution Envs (one per line)", value=_list_to_text(data, 'os_execution_envs'), key=f"{key_prefix}_mal_os")
         form_values['mal_architecture_execution_envs_str'] = st.text_area("Architecture Execution Envs (e.g., x86)", value=_list_to_text(data, 'architecture_execution_envs'), key=f"{key_prefix}_mal_arch")
         form_values['mal_implementation_languages_str'] = st.text_area("Implementation Languages (e.g., c++)", value=_list_to_text(data, 'implementation_languages'), key=f"{key_prefix}_mal_langs")
         form_values['mal_capabilities_str'] = st.text_area("Capabilities (one per line)", value=_list_to_text(data, 'capabilities'), key=f"{key_prefix}_mal_caps")
         form_values['mal_sample_refs_str'] = st.text_area("Sample Refs (STIX IDs, one per line)", value=_list_to_text(data, 'sample_refs'), key=f"{key_prefix}_mal_samples")
    elif obj_type == 'malware-analysis': # UPDATED
        form_values['ma_product'] = st.text_input("Product (Required)", value=_get_default(data, 'product'), key=f"{key_prefix}_ma_product")
        form_values['ma_version'] = st.text_input("Product Version", value=_get_default(data, 'version'), key=f"{key_prefix}_ma_version")
        form_values['ma_host_vm_ref'] = st.text_input("Host VM Ref (Software ID)", value=_get_default(data, 'host_vm_ref'), key=f"{key_prefix}_ma_host_vm")
        form_values['ma_operating_system_ref'] = st.text_input("Operating System Ref (Software ID)", value=_get_default(data, 'operating_system_ref'), key=f"{key_prefix}_ma_os")
        form_values['ma_installed_software_refs_str'] = st.text_area("Installed Software Refs (Software IDs, one per line)", value=_list_to_text(data, 'installed_software_refs'), key=f"{key_prefix}_ma_inst_sw")
        form_values['ma_configuration_version'] = st.text_input("Configuration Version", value=_get_default(data, 'configuration_version'), key=f"{key_prefix}_ma_config")
        form_values['ma_modules_str'] = st.text_area("Modules (one per line)", value=_list_to_text(data, 'modules'), key=f"{key_prefix}_ma_modules")
        form_values['ma_analysis_engine_version'] = st.text_input("Analysis Engine Version", value=_get_default(data, 'analysis_engine_version'), key=f"{key_prefix}_ma_engine_ver")
        form_values['ma_analysis_definition_version'] = st.text_input("Analysis Definition Version", value=_get_default(data, 'analysis_definition_version'), key=f"{key_prefix}_ma_def_ver")
        datetime_input("Submitted", "submitted"); datetime_input("Analysis Started", "analysis_started"); datetime_input("Analysis Ended", "analysis_ended")
        form_values['ma_av_result'] = st.selectbox("AV Result", options=MALWARE_AV_RESULT_OV, index=MALWARE_AV_RESULT_OV.index(_get_default(data, 'av_result', "")), key=f"{key_prefix}_ma_av_result")
        form_values['ma_analysis_sco_refs_str'] = st.text_area("Analysis SCO Refs (STIX IDs, one per line)", value=_list_to_text(data, 'analysis_sco_refs'), key=f"{key_prefix}_ma_sco_refs")
        st.caption("Note: Either AV Result or Analysis SCO Refs must be provided.")
    elif obj_type == 'note': # UPDATED
        form_values['note_abstract'] = st.text_area("Abstract", value=_get_default(data, 'abstract'), key=f"{key_prefix}_note_abstract")
        form_values['note_content'] = st.text_area("Content (Required)", value=_get_default(data, 'content'), key=f"{key_prefix}_note_content")
        form_values['note_authors_str'] = st.text_area("Authors (one per line)", value=_list_to_text(data, 'authors'), key=f"{key_prefix}_note_authors")
        form_values['note_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_note_obj_refs")
    elif obj_type == 'observed-data':
        datetime_input("First Observed", "first_observed", required=True); datetime_input("Last Observed", "last_observed", required=True)
        form_values['obs_number_observed'] = st.number_input("Number Observed (Required)", min_value=1, value=data.get('number_observed', 1), key=f"{key_prefix}_obs_num")
        form_values['obs_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_obs_obj_refs", help="IDs of SCOs or SROs observed")
    elif obj_type == 'report': # UPDATED
        # Name and Description are handled by the generic fields at the top
        form_values['rep_report_types'] = st.multiselect("Report Types (Required)", options=REPORT_TYPES_OV[1:], default=data.get('report_types', []), key=f"{key_prefix}_rep_types")
        datetime_input("Published Date", "published", required=True)
        form_values['rep_object_refs_str'] = st.text_area("Object Refs (Required, STIX IDs one per line)", value=_list_to_text(data, 'object_refs'), key=f"{key_prefix}_rep_obj_refs")
    elif obj_type == 'threat-actor':
        form_values['ta_threat_actor_types'] = st.multiselect("Threat Actor Types (Required)", options=THREAT_ACTOR_TYPES_OV[1:], default=data.get('threat_actor_types', []), key=f"{key_prefix}_ta_types")
        form_values['ta_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_ta_aliases")
        datetime_input("First Seen", "first_seen"); datetime_input("Last Seen", "last_seen")
        form_values['ta_roles'] = st.multiselect("Roles", options=THREAT_ACTOR_ROLES_OV[1:], default=data.get('roles', []), key=f"{key_prefix}_ta_roles")
        form_values['ta_goals_str'] = st.text_area("Goals (one per line)", value=_list_to_text(data, 'goals'), key=f"{key_prefix}_ta_goals")
        form_values['ta_sophistication'] = st.selectbox("Sophistication", options=THREAT_ACTOR_SOPHISTICATION_OV, index=THREAT_ACTOR_SOPHISTICATION_OV.index(_get_default(data, 'sophistication', "")), key=f"{key_prefix}_ta_sophistication")
        form_values['ta_resource_level'] = st.selectbox("Resource Level", options=ATTACK_RESOURCE_LEVEL_OV, index=ATTACK_RESOURCE_LEVEL_OV.index(_get_default(data, 'resource_level', "")), key=f"{key_prefix}_ta_resource_level")
        form_values['ta_primary_motivation'] = st.selectbox("Primary Motivation", options=ATTACK_MOTIVATION_OV, index=ATTACK_MOTIVATION_OV.index(_get_default(data, 'primary_motivation', "")), key=f"{key_prefix}_ta_primary_motivation")
        form_values['ta_secondary_motivations'] = st.multiselect("Secondary Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('secondary_motivations', []), key=f"{key_prefix}_ta_secondary_motivations")
        form_values['ta_personal_motivations'] = st.multiselect("Personal Motivations", options=ATTACK_MOTIVATION_OV[1:], default=data.get('personal_motivations', []), key=f"{key_prefix}_ta_personal_motivations")
    elif obj_type == 'tool': # UPDATED
         form_values['t_tool_types'] = st.multiselect("Tool Types", options=TOOL_TYPES_OV[1:], default=data.get('tool_types', []), key=f"{key_prefix}_t_types")
         form_values['t_aliases_str'] = st.text_area("Aliases (one per line)", value=_list_to_text(data, 'aliases'), key=f"{key_prefix}_t_aliases")
         kill_chain_input("t") # Add kill chain input specific to tool
         form_values['t_tool_version'] = st.text_input("Tool Version", value=_get_default(data, 'tool_version'), key=f"{key_prefix}_t_version")
    elif obj_type == 'vulnerability':
         # Use number_input for CVSS scores
         form_values['vuln_cvssv2_score'] = st.number_input("CVSSv2 Score", value=data.get('cvssV2_score'), min_value=0.0, max_value=10.0, format="%.1f", key=f"{key_prefix}_vuln_cvss2")
         form_values['vuln_cvssv3_score'] = st.number_input("CVSSv3 Score", value=data.get('cvssV3_score'), min_value=0.0, max_value=10.0, format="%.1f", key=f"{key_prefix}_vuln_cvss3")
    elif obj_type == 'x509-certificate':
        form_values['cert_is_self_signed'] = st.checkbox("Is Self-Signed?", value=data.get('is_self_signed', False), key=f"{key_prefix}_cert_self_signed")
        form_values['cert_hashes_str'] = st.text_area("Hashes (HASH_ALGO:value, one per line)", value=_hashes_to_text(data.get('hashes')), key=f"{key_prefix}_cert_hashes")
        form_values['cert_version'] = st.text_input("Version", value=_get_default(data, 'version'), key=f"{key_prefix}_cert_version")
        form_values['cert_serial_number'] = st.text_input("Serial Number", value=_get_default(data, 'serial_number'), key=f"{key_prefix}_cert_serial")
        form_values['cert_signature_algorithm'] = st.text_input("Signature Algorithm", value=_get_default(data, 'signature_algorithm'), key=f"{key_prefix}_cert_sig_algo")
        form_values['cert_issuer'] = st.text_input("Issuer", value=_get_default(data, 'issuer'), key=f"{key_prefix}_cert_issuer")
        datetime_input("Validity Not Before", "validity_not_before")
        datetime_input("Validity Not After", "validity_not_after")
        form_values['cert_subject'] = st.text_input("Subject", value=_get_default(data, 'subject'), key=f"{key_prefix}_cert_subject")
        form_values['cert_subject_public_key_algorithm'] = st.text_input("Subject Public Key Algorithm", value=_get_default(data, 'subject_public_key_algorithm'), key=f"{key_prefix}_cert_subj_pk_algo")
        form_values['cert_subject_public_key_modulus'] = st.text_area("Subject Public Key Modulus", value=_get_default(data, 'subject_public_key_modulus'), key=f"{key_prefix}_cert_subj_pk_mod")
        form_values['cert_subject_public_key_exponent'] = st.number_input("Subject Public Key Exponent", value=data.get('subject_public_key_exponent'), step=1, key=f"{key_prefix}_cert_subj_pk_exp")
        # Handle JSON input for extensions
        default_ext_json = json.dumps(data.get('x509_v3_extensions'), indent=2) if data.get('x509_v3_extensions') else ""
        form_values['cert_x509_v3_extensions_json'] = st.text_area("X.509 v3 Extensions (JSON)", value=default_ext_json, height=150, key=f"{key_prefix}_cert_ext")
    elif obj_type == 'domain-name':
        form_values['domain_value'] = st.text_input("Value (Required)", value=_get_default(data, 'value'), key=f"{key_prefix}_domain_value")
        form_values['domain_resolves_to_refs_str'] = st.text_area("Resolves To Refs (STIX IDs, one per line)", value=_list_to_text(data, 'resolves_to_refs'), key=f"{key_prefix}_domain_resolves")
    elif obj_type == 'software': # UPDATED
        # Name and description handled above
        form_values['sw_cpe'] = st.text_input("CPE", value=_get_default(data, 'cpe'), key=f"{key_prefix}_sw_cpe")
        form_values['sw_swid'] = st.text_input("SWID", value=_get_default(data, 'swid'), key=f"{key_prefix}_sw_swid")
        form_values['sw_languages_str'] = st.text_area("Languages (one per line)", value=_list_to_text(data, 'languages'), key=f"{key_prefix}_sw_langs")
        form_values['sw_vendor'] = st.text_input("Vendor", value=_get_default(data, 'vendor'), key=f"{key_prefix}_sw_vendor")
        form_values['sw_version'] = st.text_input("Version", value=_get_default(data, 'version'), key=f"{key_prefix}_sw_version")

    # --- Common Labels Field (for SDOs/SCOs that support it) ---
    # Add a 'labels' field for types that support it, excluding relationships, markings, etc.
    if obj_type not in ['relationship', 'marking-definition', 'language-content']:
         form_values[f'{obj_type}_labels_str'] = st.text_area("Labels (Optional, one per line)", value=_list_to_text(data, 'labels'), key=f"{key_prefix}_{obj_type}_labels")
    # --- END Common Labels ---

    # --- External Reference Fields ---
    # Add fields for a single external reference, applicable to SDOs and Relationships
    # Exclude SCOs, Note, Software, MalwareAnalysis as they don't directly have this property structure
    if obj_type not in ['x509-certificate', 'domain-name', 'note', 'software', 'file', 'ipv4-addr', 'ipv6-addr', 'url', 'directory', 'email-addr', 'email-message', 'mac-addr', 'mutex', 'network-traffic', 'process', 'user-account', 'windows-registry-key', 'malware-analysis']: # Added MA
        st.subheader("External Reference (Optional)")
        # Get data from the first external reference if it exists
        ext_ref_data = data.get('external_references', [{}])[0]
        form_values['ext_ref_source_name'] = st.text_input("Source Name", value=_get_default(ext_ref_data, 'source_name'), key=f"{key_prefix}_ext_ref_source")
        form_values['ext_ref_description'] = st.text_input("Description", value=_get_default(ext_ref_data, 'description'), key=f"{key_prefix}_ext_ref_desc")
        form_values['ext_ref_url'] = st.text_input("URL", value=_get_default(ext_ref_data, 'url'), key=f"{key_prefix}_ext_ref_url")
        form_values['ext_ref_external_id'] = st.text_input("External ID", value=_get_default(ext_ref_data, 'external_id'), key=f"{key_prefix}_ext_ref_ext_id")
        form_values['ext_ref_hashes_str'] = st.text_area("Hashes (HASH_ALGO:value)", value=_ext_ref_hashes_to_text(data.get('external_references')), key=f"{key_prefix}_ext_ref_hashes")

    return form_values


def parse_form_data_to_stix_args(form_data, obj_type, key_prefix): # <-- Add key_prefix here
    """
    Converts raw form data from Streamlit widgets into a dictionary suitable
    for stix2 library constructors or update methods.

    Args:
        form_data (dict): The dictionary containing values from the form widgets.
        obj_type (str): The type of the STIX object being parsed.

    Returns:
        dict: A dictionary of arguments ready to be passed to stix2 functions.
              Keys are STIX property names, values are formatted appropriately.
    """
    obj_args = {} # Dictionary to build arguments for stix2 library

    # --- Helper function to parse multiline text areas into lists ---
    def parse_text_area(text_area_str):
        """Splits a multiline string into a list of stripped strings, ignoring empty lines."""
        return [item.strip() for item in text_area_str.splitlines() if item.strip()]

    # --- Helper function to format date and time into STIX timestamp string ---
    def format_stix_timestamp(date_val, time_val):
        """Combines date and time objects into a STIX compliant UTC timestamp string."""
        if date_val is None: return None # Cannot create timestamp without date
        # Default to midnight if time is not provided
        time_val = time_val or dt_time(0, 0, 0)
        try:
            # Combine date and time, ensure timezone is UTC
            combined_dt = datetime.combine(date_val, time_val).replace(tzinfo=timezone.utc)
            # Format according to STIX spec (ISO 8601 with Z)
            # Use .%f to get microseconds, then slice to get milliseconds
            return combined_dt.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + "Z"
        except Exception as e:
            st.error(f"Error combining date/time: {e}")
            return None

    # --- Helper function to parse hash strings (e.g., "MD5:...") into dict ---
    def parse_hashes_str(hashes_str):
        """Parses a multiline string of 'ALGO:hash' into a dictionary."""
        hashes_dict = {}
        for line in hashes_str.splitlines():
            if ':' in line:
                parts = line.split(':', 1)
                algo = parts[0].strip().upper() # Ensure algo is uppercase
                hash_val = parts[1].strip()
                # Only include valid hash algorithms from the vocabulary
                if algo in HASH_ALGO_OV and algo != "":
                    hashes_dict[algo] = hash_val
        return hashes_dict if hashes_dict else None # Return None if empty

    # --- Explicitly add 'type' to the arguments ---
    # This was identified as a potential issue in the analysis. Ensure type is always included.
    obj_args['type'] = obj_type

    # --- Generic Fields (if applicable) ---
    # Handle common fields like name and description if present in form_data
    if form_data.get('name'): obj_args['name'] = form_data['name']
    if form_data.get('description'): obj_args['description'] = form_data['description']

    # --- Parse Common Labels Field ---
    # Find the key for the labels text area (it includes the object type prefix)
    labels_key = next((k for k in form_data if k.endswith('_labels_str')), None)  # Level 2
    labels_list = [] # Initialize as empty list                                     # Level 2

    # Check if the labels text area key exists and has content typed by the user
    if labels_key and form_data.get(labels_key):                                   # Level 2
        # Parse the text area content into a list
        labels_list = parse_text_area(form_data[labels_key])                       # Level 3 (Inside the 'if')

    # Check the context (key_prefix) passed to the function
    # If adding a new object ('add') AND the user didn't provide any labels
    if key_prefix == "add" and not labels_list:                                    # Level 2
            # Add the default label to the arguments for the stix2 library
            obj_args['labels'] = ["bridewell-cti"]                                    # Level 3 (Inside the 'if')
    # Else if the user DID provide labels (either when adding or editing)
    elif labels_list:                                                              # Level 2
            # Add the user-provided labels to the arguments
            obj_args['labels'] = labels_list                                          # Level 3 (Inside the 'elif')
    # Else (means we are editing AND the user provided no labels),
    # we simply do nothing, ensuring the 'labels' key is NOT added to obj_args.
    # This correctly removes the labels property if cleared during an edit.

    # --- Type Specific Parsing --- # <<< Make sure this line follows immediately after the block above (Level 2)

    # --- Type Specific Parsing ---
    # Parse fields based on the object type
    if obj_type == 'attack-pattern':
        if form_data.get('ap_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['ap_aliases_str'])
    elif obj_type == 'campaign': # UPDATED
        if form_data.get('c_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['c_aliases_str'])
        # Format timestamps, add to args only if valid
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('c_objective'): obj_args['objective'] = form_data['c_objective']
    elif obj_type == 'course-of-action': # UPDATED
        # Name and Description handled by generic fields
        pass # No other specific fields to parse
    elif obj_type == 'identity':
        if form_data.get('id_identity_class'): obj_args['identity_class'] = form_data['id_identity_class']
        if form_data.get('id_sectors'): obj_args['sectors'] = form_data['id_sectors'] # Multiselect returns list directly
        if form_data.get('id_contact_information'): obj_args['contact_information'] = form_data['id_contact_information']
    elif obj_type == 'indicator': # UPDATED
        if form_data.get('ind_indicator_types'): obj_args['indicator_types'] = form_data['ind_indicator_types'] # Multiselect
        # Required fields for Indicator
        if form_data.get('ind_pattern_type'): obj_args['pattern_type'] = form_data['ind_pattern_type']
        if form_data.get('ind_pattern'): obj_args['pattern'] = form_data['ind_pattern']
        ts = format_stix_timestamp(form_data.get('valid_from_date'), form_data.get('valid_from_time')); # Required
        if ts: obj_args['valid_from'] = ts # Add if valid
        # Optional timestamp
        ts = format_stix_timestamp(form_data.get('valid_until_date'), form_data.get('valid_until_time')); obj_args.update({'valid_until': ts} if ts else {})
    elif obj_type == 'infrastructure': # UPDATED
        if form_data.get('inf_infrastructure_types'): obj_args['infrastructure_types'] = form_data['inf_infrastructure_types'] # Multiselect
        if form_data.get('inf_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['inf_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
    elif obj_type == 'intrusion-set': # UPDATED
        if form_data.get('is_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['is_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('is_goals_str'): obj_args['goals'] = parse_text_area(form_data['is_goals_str'])
        if form_data.get('is_resource_level'): obj_args['resource_level'] = form_data['is_resource_level']
        if form_data.get('is_primary_motivation'): obj_args['primary_motivation'] = form_data['is_primary_motivation']
        if form_data.get('is_secondary_motivations'): obj_args['secondary_motivations'] = form_data['is_secondary_motivations'] # Multiselect
    elif obj_type == 'location':
        if form_data.get('loc_region'): obj_args['region'] = form_data['loc_region']
        if form_data.get('loc_country'): obj_args['country'] = form_data['loc_country']
        if form_data.get('loc_administrative_area'): obj_args['administrative_area'] = form_data['loc_administrative_area']
        if form_data.get('loc_city'): obj_args['city'] = form_data['loc_city']
        if form_data.get('loc_street_address'): obj_args['street_address'] = form_data['loc_street_address']
        if form_data.get('loc_postal_code'): obj_args['postal_code'] = form_data['loc_postal_code']
        # Handle float conversion for geo coordinates/precision
        if form_data.get('loc_latitude') is not None:
            try: obj_args['latitude'] = float(form_data['loc_latitude'])
            except (ValueError, TypeError): pass # Ignore if conversion fails
        if form_data.get('loc_longitude') is not None:
             try: obj_args['longitude'] = float(form_data['loc_longitude'])
             except (ValueError, TypeError): pass
        if form_data.get('loc_precision') is not None:
             try: obj_args['precision'] = float(form_data['loc_precision'])
             except (ValueError, TypeError): pass
    elif obj_type == 'malware': # UPDATED
        if form_data.get('mal_malware_types'): obj_args['malware_types'] = form_data['mal_malware_types'] # Required if not is_family
        obj_args['is_family'] = form_data.get('mal_is_family', False) # Checkbox value
        if form_data.get('mal_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['mal_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('mal_os_execution_envs_str'): obj_args['os_execution_envs'] = parse_text_area(form_data['mal_os_execution_envs_str'])
        if form_data.get('mal_architecture_execution_envs_str'): obj_args['architecture_execution_envs'] = parse_text_area(form_data['mal_architecture_execution_envs_str'])
        if form_data.get('mal_implementation_languages_str'): obj_args['implementation_languages'] = parse_text_area(form_data['mal_implementation_languages_str'])
        if form_data.get('mal_capabilities_str'): obj_args['capabilities'] = parse_text_area(form_data['mal_capabilities_str'])
        if form_data.get('mal_sample_refs_str'): obj_args['sample_refs'] = parse_text_area(form_data['mal_sample_refs_str'])
    elif obj_type == 'malware-analysis': # UPDATED
        if form_data.get('ma_product'): obj_args['product'] = form_data['ma_product'] # Required
        if form_data.get('ma_version'): obj_args['version'] = form_data['ma_version']
        if form_data.get('ma_host_vm_ref'): obj_args['host_vm_ref'] = form_data['ma_host_vm_ref']
        if form_data.get('ma_operating_system_ref'): obj_args['operating_system_ref'] = form_data['ma_operating_system_ref']
        if form_data.get('ma_installed_software_refs_str'): obj_args['installed_software_refs'] = parse_text_area(form_data['ma_installed_software_refs_str'])
        if form_data.get('ma_configuration_version'): obj_args['configuration_version'] = form_data['ma_configuration_version']
        if form_data.get('ma_modules_str'): obj_args['modules'] = parse_text_area(form_data['ma_modules_str'])
        if form_data.get('ma_analysis_engine_version'): obj_args['analysis_engine_version'] = form_data['ma_analysis_engine_version']
        if form_data.get('ma_analysis_definition_version'): obj_args['analysis_definition_version'] = form_data['ma_analysis_definition_version']
        ts = format_stix_timestamp(form_data.get('submitted_date'), form_data.get('submitted_time')); obj_args.update({'submitted': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('analysis_started_date'), form_data.get('analysis_started_time')); obj_args.update({'analysis_started': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('analysis_ended_date'), form_data.get('analysis_ended_time')); obj_args.update({'analysis_ended': ts} if ts else {})
        if form_data.get('ma_av_result'): obj_args['av_result'] = form_data['ma_av_result']
        if form_data.get('ma_analysis_sco_refs_str'): obj_args['analysis_sco_refs'] = parse_text_area(form_data['ma_analysis_sco_refs_str'])
    elif obj_type == 'note': # UPDATED
        if form_data.get('note_abstract'): obj_args['abstract'] = form_data['note_abstract']
        if form_data.get('note_content'): obj_args['content'] = form_data['note_content'] # Required
        if form_data.get('note_authors_str'):
            authors = parse_text_area(form_data['note_authors_str'])
            if authors: obj_args['authors'] = authors # Add only if list is not empty
        if form_data.get('note_object_refs_str'):
            refs = parse_text_area(form_data['note_object_refs_str'])
            if refs: obj_args['object_refs'] = refs # Required, add if not empty
    elif obj_type == 'observed-data':
        # Required fields
        ts = format_stix_timestamp(form_data.get('first_observed_date'), form_data.get('first_observed_time')); obj_args.update({'first_observed': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_observed_date'), form_data.get('last_observed_time')); obj_args.update({'last_observed': ts} if ts else {})
        if form_data.get('obs_number_observed') is not None: obj_args['number_observed'] = form_data['obs_number_observed']
        if form_data.get('obs_object_refs_str'): obj_args['object_refs'] = parse_text_area(form_data['obs_object_refs_str'])
    elif obj_type == 'report': # UPDATED
        # Name and Description handled by generic fields
        # Required fields
        if form_data.get('rep_report_types'): obj_args['report_types'] = form_data['rep_report_types'] # Multiselect
        ts = format_stix_timestamp(form_data.get('published_date'), form_data.get('published_time')) # Required
        if ts: obj_args['published'] = ts
        if form_data.get('rep_object_refs_str'):
            refs = parse_text_area(form_data['rep_object_refs_str'])
            if refs: obj_args['object_refs'] = refs # Required
    elif obj_type == 'threat-actor':
        if form_data.get('ta_threat_actor_types'): obj_args['threat_actor_types'] = form_data['ta_threat_actor_types'] # Required
        if form_data.get('ta_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['ta_aliases_str'])
        ts = format_stix_timestamp(form_data.get('first_seen_date'), form_data.get('first_seen_time')); obj_args.update({'first_seen': ts} if ts else {})
        ts = format_stix_timestamp(form_data.get('last_seen_date'), form_data.get('last_seen_time')); obj_args.update({'last_seen': ts} if ts else {})
        if form_data.get('ta_roles'): obj_args['roles'] = form_data['ta_roles'] # Multiselect
        if form_data.get('ta_goals_str'): obj_args['goals'] = parse_text_area(form_data['ta_goals_str'])
        if form_data.get('ta_sophistication'): obj_args['sophistication'] = form_data['ta_sophistication']
        if form_data.get('ta_resource_level'): obj_args['resource_level'] = form_data['ta_resource_level']
        if form_data.get('ta_primary_motivation'): obj_args['primary_motivation'] = form_data['ta_primary_motivation']
        if form_data.get('ta_secondary_motivations'): obj_args['secondary_motivations'] = form_data['ta_secondary_motivations'] # Multiselect
        if form_data.get('ta_personal_motivations'): obj_args['personal_motivations'] = form_data['ta_personal_motivations'] # Multiselect
    elif obj_type == 'tool': # UPDATED
        if form_data.get('t_tool_types'): obj_args['tool_types'] = form_data['t_tool_types'] # Multiselect
        if form_data.get('t_aliases_str'): obj_args['aliases'] = parse_text_area(form_data['t_aliases_str'])
        if form_data.get('t_tool_version'): obj_args['tool_version'] = form_data['t_tool_version']
    elif obj_type == 'vulnerability':
        # Handle float conversion for CVSS scores
        if form_data.get('vuln_cvssv2_score') is not None:
             try: obj_args['cvssV2_score'] = float(form_data['vuln_cvssv2_score'])
             except (ValueError, TypeError): pass
        if form_data.get('vuln_cvssv3_score') is not None:
             try: obj_args['cvssV3_score'] = float(form_data['vuln_cvssv3_score'])
             except (ValueError, TypeError): pass
    elif obj_type == 'x509-certificate':
        obj_args['is_self_signed'] = form_data.get('cert_is_self_signed', False) # Checkbox
        if form_data.get('cert_hashes_str'):
            hashes = parse_hashes_str(form_data['cert_hashes_str'])
            if hashes: obj_args['hashes'] = hashes # Add only if valid hashes found
        if form_data.get('cert_version'): obj_args['version'] = form_data['cert_version']
        if form_data.get('cert_serial_number'): obj_args['serial_number'] = form_data['cert_serial_number']
        if form_data.get('cert_signature_algorithm'): obj_args['signature_algorithm'] = form_data['cert_signature_algorithm']
        if form_data.get('cert_issuer'): obj_args['issuer'] = form_data['cert_issuer']
        # Timestamps
        ts = format_stix_timestamp(form_data.get('validity_not_before_date'), form_data.get('validity_not_before_time'))
        if ts: obj_args['validity_not_before'] = ts
        ts = format_stix_timestamp(form_data.get('validity_not_after_date'), form_data.get('validity_not_after_time'))
        if ts: obj_args['validity_not_after'] = ts
        # Subject details
        if form_data.get('cert_subject'): obj_args['subject'] = form_data['cert_subject']
        if form_data.get('cert_subject_public_key_algorithm'): obj_args['subject_public_key_algorithm'] = form_data['cert_subject_public_key_algorithm']
        if form_data.get('cert_subject_public_key_modulus'): obj_args['subject_public_key_modulus'] = form_data['cert_subject_public_key_modulus']
        # Handle integer conversion for exponent
        if form_data.get('cert_subject_public_key_exponent') is not None:
             try: obj_args['subject_public_key_exponent'] = int(form_data['cert_subject_public_key_exponent'])
             except (ValueError, TypeError): st.warning("Invalid input for public key exponent, expected integer.")
        # Handle JSON parsing for extensions
        if form_data.get('cert_x509_v3_extensions_json'):
            try:
                ext_data = json.loads(form_data['cert_x509_v3_extensions_json'])
                if isinstance(ext_data, dict): # Ensure it's a dictionary
                     obj_args['x509_v3_extensions'] = ext_data
                else: st.warning("X.509 v3 Extensions input is not valid JSON dictionary, skipping.")
            except json.JSONDecodeError: st.warning("X.509 v3 Extensions input is not valid JSON, skipping.")
    elif obj_type == 'domain-name':
        if form_data.get('domain_value'): obj_args['value'] = form_data['domain_value'] # Required
        if form_data.get('domain_resolves_to_refs_str'):
            refs = parse_text_area(form_data['domain_resolves_to_refs_str'])
            if refs: obj_args['resolves_to_refs'] = refs # Add if not empty
    elif obj_type == 'software': # UPDATED
        # Name and description parsed above
        if form_data.get('sw_cpe'): obj_args['cpe'] = form_data['sw_cpe']
        if form_data.get('sw_swid'): obj_args['swid'] = form_data['sw_swid']
        if form_data.get('sw_languages_str'): obj_args['languages'] = parse_text_area(form_data['sw_languages_str'])
        if form_data.get('sw_vendor'): obj_args['vendor'] = form_data['sw_vendor']
        if form_data.get('sw_version'): obj_args['version'] = form_data['sw_version']

    # --- Kill Chain Phase Processing (Applies to relevant types) ---
    # Map object type to the prefix used in form keys for kill chain fields
    kc_prefix_map = {'attack-pattern': 'ap', 'indicator': 'ind', 'infrastructure': 'inf', 'malware': 'mal', 'tool': 't'}
    kc_prefix = kc_prefix_map.get(obj_type)
    if kc_prefix:
        selected_kc_name = form_data.get(f'{kc_prefix}_kc_name') # e.g., 'ap_kc_name'
        phase_name = form_data.get(f'{kc_prefix}_phase_name') # e.g., 'ap_phase_name' or custom input
        final_kc_name = None

        # Determine the actual kill chain name (standard or custom)
        if selected_kc_name == "custom":
            final_kc_name = form_data.get(f'{kc_prefix}_custom_kc_name') # Get from custom input
        elif selected_kc_name and selected_kc_name != "custom": # Check it's a standard name and not empty
            final_kc_name = selected_kc_name

        # If both kill chain name and phase name are valid, construct the kill_chain_phases list
        if final_kc_name and phase_name:
            # Ensure names are lowercase and hyphenated as per STIX convention
            obj_args['kill_chain_phases'] = [{'kill_chain_name': final_kc_name.lower().replace(" ", "-"),
                                              'phase_name': phase_name.lower().replace(" ", "-")}]
        elif 'kill_chain_phases' in obj_args:
            # If selection is no longer valid (e.g., cleared), remove the property
            del obj_args['kill_chain_phases']

    # --- External Reference Processing ---
    # Applicable to SDOs/Relationships, excluding SCOs, Note, Software, MalwareAnalysis
    if obj_type not in ['x509-certificate', 'domain-name', 'note', 'software', 'file', 'ipv4-addr', 'ipv6-addr', 'url', 'directory', 'email-addr', 'email-message', 'mac-addr', 'mutex', 'network-traffic', 'process', 'user-account', 'windows-registry-key', 'malware-analysis']: # Added MA
        ext_ref_source = form_data.get('ext_ref_source_name')
        ext_ref_desc = form_data.get('ext_ref_description')
        ext_ref_url = form_data.get('ext_ref_url')
        ext_ref_ext_id = form_data.get('ext_ref_external_id')
        ext_ref_hashes_str = form_data.get('ext_ref_hashes_str')

        # Only create external_references list if at least source_name is provided
        # and one other field has content.
        if ext_ref_source and (ext_ref_desc or ext_ref_url or ext_ref_ext_id or ext_ref_hashes_str):
            ext_ref = {"source_name": ext_ref_source} # Start with required source_name
            # Add optional fields if they have values
            if ext_ref_desc: ext_ref["description"] = ext_ref_desc
            if ext_ref_url: ext_ref["url"] = ext_ref_url
            if ext_ref_ext_id: ext_ref["external_id"] = ext_ref_ext_id
            if ext_ref_hashes_str:
                hashes = parse_hashes_str(ext_ref_hashes_str)
                if hashes: ext_ref["hashes"] = hashes # Add hashes dict if valid
            # Assign the list containing the single reference
            obj_args["external_references"] = [ext_ref]
        elif "external_references" in obj_args:
             # If source name was cleared during edit, remove the property
             del obj_args["external_references"]


    # --- Clean up empty/None optional fields ---
    # Remove keys with empty/None values unless they are required or specific cases like booleans.
    required_fields = {
        'indicator': ['pattern_type', 'pattern', 'valid_from'],
        'note': ['content', 'object_refs'],
        'observed-data': ['first_observed', 'last_observed', 'number_observed', 'object_refs'],
        'report': ['name', 'report_types', 'published', 'object_refs'],
        'threat-actor': ['threat_actor_types'],
        'course-of-action': ['name'],
        'malware-analysis': ['product'], # Added MA requirement
        'domain-name': ['value'],
        'software': ['name'],
        # Add other types and their required fields as needed
    }
    # Fields that should be kept even if None/empty (e.g., optional timestamps, booleans)
    keep_if_empty_or_none = [
        'first_seen', 'last_seen', 'valid_until', 'published',
        'first_observed', 'last_observed', 'validity_not_before', 'validity_not_after',
        'submitted', 'analysis_started', 'analysis_ended', # MA timestamps
        'is_family', 'is_self_signed' # Booleans
    ]

    args_copy = obj_args.copy() # Iterate over a copy
    for key, value in args_copy.items():
        is_required = key in required_fields.get(obj_type, [])
        keep_anyway = key in keep_if_empty_or_none

        # Check if the value is considered "empty" (None, empty string, empty list/dict)
        is_empty = value is None or value == "" or value == [] or value == {}

        # Remove if it's not required, not explicitly kept, AND it's empty
        if not is_required and not keep_anyway and is_empty:
            # Check if key exists before deleting (important for edit form)
            if key in obj_args:
                del obj_args[key]

    return obj_args

# --- Main App ---
st.title("STIX 2.1 Visualizer & Editor")
load_status_placeholder = st.empty() # Placeholder for loading messages

# --- Sidebar ---
with st.sidebar:
    # --- ADDED LOGO ---
    logo_uri = get_sidebar_logo_uri()
    if logo_uri:
        # Display the logo and username using Markdown for better control over layout
        st.markdown(
            f"""
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <img src="{logo_uri}" style="height: 40px; width: 40px; border-radius: 50%; margin-right: 10px;">
                <span style="font-weight: bold; font-size: 1.1em;">@m4nbat</span>
            </div>
            """,
            unsafe_allow_html=True
        )
    # --- END LOGO ---

    # --- Load Bundle ---
    with st.expander("Load STIX 2.1 Bundle", expanded=True):
        # File uploader widget
        uploaded_file = st.file_uploader("Upload STIX 2.1 JSON bundle", type=["json"], key="stix_uploader_widget")

        # Update session state if a new file is uploaded
        if uploaded_file is not None and uploaded_file != st.session_state.uploaded_file_state:
            st.session_state.uploaded_file_state = uploaded_file
            load_status_placeholder.empty() # Clear previous status messages
            # Reset editing state when a new file is uploaded
            st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None

        # Button to trigger bundle processing
        process_button = st.button("Load and Process Bundle", disabled=(st.session_state.uploaded_file_state is None), key="load_process_button")

    # --- Processing Logic ---
    # Execute if the process button is clicked and a file is available
    if st.session_state.get("load_process_button") and st.session_state.uploaded_file_state is not None:
        # Use st.status for progress indication
        with st.status(f"Loading '{st.session_state.uploaded_file_state.name}'...", expanded=True) as status:
            try:
                current_uploaded_file = st.session_state.uploaded_file_state
                load_status_placeholder.info(f"Processing '{current_uploaded_file.name}'...")
                status.write(" Resetting current graph..."); time.sleep(0.1) # Simulate work

                # Reset session state for graph data and selections
                st.session_state.objects = []; st.session_state.nodes = []; st.session_state.edges = []
                st.session_state.current_selection = None; st.session_state.rel_source_sel = None; st.session_state.rel_target_sel = None
                st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None

                status.write(f" Reading file '{current_uploaded_file.name}'..."); time.sleep(0.1)
                bundle_content_bytes = current_uploaded_file.getvalue()
                if not bundle_content_bytes:
                    status.update(label="Error: Uploaded file is empty.", state="error", expanded=True)
                    load_status_placeholder.error(" Error: Uploaded file is empty.")
                    st.stop() # Stop execution if file is empty

                # Decode file content (try UTF-8 with BOM first, then plain UTF-8)
                try: bundle_content_str = bundle_content_bytes.decode('utf-8-sig')
                except UnicodeDecodeError:
                    try: bundle_content_str = bundle_content_bytes.decode('utf-8')
                    except UnicodeDecodeError as decode_e:
                        status.update(label=f"Error decoding file: {decode_e}", state="error", expanded=True)
                        load_status_placeholder.error(f" Error decoding file: Use UTF-8 encoding. Details: {decode_e}")
                        st.stop()

                status.write(" Parsing JSON data..."); time.sleep(0.1)
                # Parse the JSON string
                try: bundle_json = json.loads(bundle_content_str)
                except json.JSONDecodeError as json_e:
                    status.update(label=f"JSON Decode Error: {json_e}", state="error", expanded=True)
                    load_status_placeholder.error(f" Invalid JSON: {json_e}")
                    st.stop()

                status.write(" Parsing STIX objects..."); time.sleep(0.1)
                # Parse the JSON into a STIX Bundle object using stix2 library
                try:
                    # allow_custom=True enables parsing of custom properties/objects
                    bundle = parse(bundle_json, allow_custom=True)
                    if not isinstance(bundle, Bundle):
                        status.update(label="Error: Parsed data is not a valid STIX Bundle.", state="error", expanded=True)
                        load_status_placeholder.error(" Error: File does not contain a valid STIX Bundle object.")
                        st.stop()
                except Exception as parse_e:
                    status.update(label=f"STIX Parsing Error: {parse_e}", state="error", expanded=True)
                    load_status_placeholder.error(f" Error parsing STIX content: {parse_e}")
                    st.stop()

                status.write(" Building graph elements..."); time.sleep(0.1)
                # Prepare lists for graph nodes, edges, and raw objects
                temp_nodes, temp_edges, temp_objects = [], [], []; skipped_objects = 0; processed_count = 0
                total_objects = len(bundle.objects) if hasattr(bundle, 'objects') and bundle.objects else 0

                # Iterate through objects in the bundle
                if total_objects > 0:
                    progress_bar = status.progress(0) # Initialize progress bar
                    for i, obj in enumerate(bundle.objects):
                        try:
                            # Basic check for essential STIX object properties
                            if not hasattr(obj, 'id') or not hasattr(obj, 'type'):
                                skipped_objects += 1; continue

                            # Serialize the object to a dictionary
                            obj_dict = json.loads(obj.serialize()); temp_objects.append(obj_dict)
                            obj_type = obj_dict['type']; obj_id = obj_dict['id']

                            # Process relationships into edges
                            if obj_type == 'relationship':
                                if 'source_ref' in obj_dict and 'target_ref' in obj_dict and 'relationship_type' in obj_dict:
                                    temp_edges.append({'data': {'id': obj_id, 'source': obj_dict['source_ref'], 'target': obj_dict['target_ref'], 'label': obj_dict['relationship_type']}})
                                else: skipped_objects += 1 # Skip incomplete relationships
                            # Process other objects (SDOs/SCOs) into nodes, excluding marking definitions
                            elif obj_type != 'marking-definition':
                                # Determine the label for the node (Name > Value > Specific Fallbacks > ID)
                                label = obj_dict.get('name', obj_dict.get('value'))
                                if obj_type == 'x509-certificate' and not label:
                                     label = obj_dict.get('serial_number', obj_dict.get('subject', obj_id))
                                elif obj_type == 'note' and not label:
                                     label = obj_dict.get('abstract', obj_id) # Use abstract for note
                                elif obj_type == 'malware-analysis' and not label: # Added MA label
                                     label = obj_dict.get('product', obj_id)
                                elif not label:
                                     label = obj_id # Fallback to ID if no other suitable label found
                                temp_nodes.append({'data': {'id': obj_id, 'label': label}})
                            processed_count += 1
                        except Exception as obj_proc_e:
                            # Catch errors during individual object processing
                            print(f"Error processing object {getattr(obj, 'id', 'UNKNOWN')}: {obj_proc_e}")
                            skipped_objects += 1
                        # Update progress bar
                        progress_bar.progress((i + 1) / total_objects, text=f"Processing object {i+1}/{total_objects}")
                    progress_bar.empty() # Remove progress bar when done

                # Update session state with the processed data
                st.session_state.objects = temp_objects; st.session_state.nodes = temp_nodes; st.session_state.edges = temp_edges

                # Display success message
                success_msg = f"Loaded {len(temp_objects)} objects ({len(temp_nodes)} nodes, {len(temp_edges)} edges)."
                if skipped_objects > 0: success_msg += f" Skipped {skipped_objects} invalid/unsupported objects."
                status.update(label="Loading Complete!", state="complete", expanded=False)
                load_status_placeholder.success(f" {success_msg}")
                st.rerun() # Rerun to update the graph display
            except Exception as e:
                # Catch any unexpected errors during the loading process
                error_label = f"Unexpected Error: {e}"; status.update(label=error_label, state="error", expanded=True); load_status_placeholder.error(f" An unexpected error occurred: {e}")

    # Handle case where process button clicked but no file uploaded
    elif st.session_state.get("load_process_button") and st.session_state.uploaded_file_state is None:
        load_status_placeholder.warning(" Please upload a file first.")

    # --- Add Object ---
    with st.expander("Add STIX Object", expanded=False):
        # Callback function to update the selected type for the add form
        def update_add_form_type():
            st.session_state.add_form_selected_type = st.session_state.add_obj_type_select_widget
            # Reset editing state when changing add type
            st.session_state.editing_object_id = None
            st.session_state.editing_relationship_id = None

        # Determine the index of the currently selected type for the selectbox default
        current_add_type_index = 0
        if st.session_state.add_form_selected_type in ALL_OBJECT_TYPES:
            current_add_type_index = ALL_OBJECT_TYPES.index(st.session_state.add_form_selected_type)

        # Selectbox for choosing the object type to add
        obj_type_selection = st.selectbox("Object Type", ALL_OBJECT_TYPES, key="add_obj_type_select_widget", index=current_add_type_index, on_change=update_add_form_type)
        add_obj_type = st.session_state.add_form_selected_type # Get the selected type from state

        # --- Form for Adding Objects ---
        # Use a unique form key based on the selected object type
        with st.form(f"add_object_detail_form_{add_obj_type}", clear_on_submit=True):
            # Generate the form fields dynamically based on the selected type
            add_form_data = generate_object_form_fields(add_obj_type, key_prefix="add")
            # Submit button for the add form
            add_obj_submit = st.form_submit_button(f"Create {add_obj_type} Object")

            # Process form submission
            if add_obj_submit:
                validation_passed = True; error_messages = []
                # --- Basic Required Field Validation ---
                # Add specific validation checks based on STIX 2.1 requirements
                if add_obj_type == 'domain-name' and not add_form_data.get('domain_value'):
                    error_messages.append("Domain Name 'Value' is required.")
                    validation_passed = False
                if add_obj_type == 'note':
                    if not add_form_data.get('note_content'): error_messages.append("Note 'Content' is required."); validation_passed = False
                    if not add_form_data.get('note_object_refs_str'): error_messages.append("Note 'Object Refs' are required."); validation_passed = False
                if add_obj_type == 'report':
                    if not add_form_data.get('name'): error_messages.append("Report 'Name' is required."); validation_passed = False
                    if not add_form_data.get('rep_report_types'): error_messages.append("Report 'Report Types' are required."); validation_passed = False
                    if not add_form_data.get('published_date'): error_messages.append("Report 'Published Date' is required."); validation_passed = False
                    if not add_form_data.get('rep_object_refs_str'): error_messages.append("Report 'Object Refs' are required."); validation_passed = False
                if add_obj_type == 'software' and not add_form_data.get('name'):
                    error_messages.append("Software 'Name' is required."); validation_passed = False
                if add_obj_type == 'course-of-action' and not add_form_data.get('name'):
                    error_messages.append("Course of Action 'Name' is required."); validation_passed = False
                if add_obj_type == 'malware-analysis':
                    if not add_form_data.get('ma_product'): error_messages.append("Malware Analysis 'Product' is required."); validation_passed = False
                    if not add_form_data.get('ma_av_result') and not add_form_data.get('ma_analysis_sco_refs_str'): error_messages.append("Malware Analysis requires either 'AV Result' or 'Analysis SCO Refs'."); validation_passed = False
                if add_obj_type == 'indicator':
                     if not add_form_data.get('ind_pattern_type'): error_messages.append("Indicator 'Pattern Type' is required."); validation_passed = False
                     if not add_form_data.get('ind_pattern'): error_messages.append("Indicator 'Pattern' is required."); validation_passed = False
                     if not add_form_data.get('valid_from_date'): error_messages.append("Indicator 'Valid From Date' is required."); validation_passed = False
                if add_obj_type == 'observed-data':
                     if not add_form_data.get('first_observed_date') or not add_form_data.get('last_observed_date') or not add_form_data.get('obs_number_observed') or not add_form_data.get('obs_object_refs_str'):
                         error_messages.append("Observed Data requires 'First Observed', 'Last Observed', 'Number Observed', and 'Object Refs'."); validation_passed = False
                if add_obj_type == 'threat-actor' and not add_form_data.get('ta_threat_actor_types'):
                     error_messages.append("Threat Actor 'Threat Actor Types' are required."); validation_passed = False
                if add_obj_type == 'malware': # Added specific Malware validation
                    if not add_form_data.get('mal_is_family', False) and not add_form_data.get('mal_malware_types'):
                         error_messages.append("Malware 'Malware Types' are required when 'Is Family' is unchecked."); validation_passed = False
                    # Malware family must have a name
                    if add_form_data.get('mal_is_family', False) and not add_form_data.get('name'):
                         error_messages.append("Malware 'Name' is required when 'Is Family' is checked."); validation_passed = False
                # --- End Validation ---

                # Display validation errors if any
                if not validation_passed:
                    for msg in error_messages: st.error(msg)

                # Proceed if validation passed and form data exists
                if validation_passed and add_form_data:
                    # Generate a new STIX ID
                    obj_id = f"{add_obj_type}--{uuid.uuid4()}"
                    # Parse the form data into arguments suitable for stix2 library
                    obj_args = parse_form_data_to_stix_args(add_form_data, add_obj_type, "add") # Pass "add"
                    # Ensure the generated ID is included
                    obj_args['id'] = obj_id
                    try:
                        # Use stix2.parse() to create the object instance.
                        # allow_custom=True handles custom properties and potentially SCOs not explicitly mapped.
                        stix_obj = parse(obj_args, allow_custom=True)

                        # Handle cases where parse might return a dict (e.g., for custom objects)
                        if isinstance(stix_obj, dict):
                             obj_dict = stix_obj
                             # Ensure essential keys are present even if parse returns dict
                             obj_dict['id'] = obj_args['id']
                             obj_dict['type'] = add_obj_type
                        else:
                             # Serialize the created stix2 object back to a dictionary
                             obj_dict = json.loads(stix_obj.serialize())

                        # Add the new object dictionary to the session state list
                        st.session_state.objects.append(obj_dict)

                        # Determine label for the new graph node
                        label = obj_args.get('name', obj_args.get('value')) # Use value for SCOs if name missing
                        if add_obj_type == 'x509-certificate' and not label:
                            label = obj_args.get('serial_number', obj_args.get('subject', obj_id))
                        elif add_obj_type == 'note' and not label:
                            label = obj_args.get('abstract', obj_id) # Use abstract for note
                        elif add_obj_type == 'malware-analysis' and not label:
                             label = obj_args.get('product', obj_id) # Use product for MA
                        elif not label:
                            label = obj_id # Fallback to ID

                        # Add the new node to the graph data in session state
                        st.session_state.nodes.append({'data': { 'id': obj_id, 'label': label }})
                        st.success(f"Created {add_obj_type}: {label}")

                        # --- Generate Maps Link AFTER successful submission ---
                        if add_obj_type == "location":
                            lat = add_form_data.get("loc_latitude")
                            lon = add_form_data.get("loc_longitude")
                            maps_url = generate_maps_link(lat, lon)
                            if maps_url:
                                # Store URL in session state to display outside the form context
                                st.session_state.map_url_to_display = maps_url
                            else:
                                st.session_state.map_url_to_display = None
                                st.warning("Could not generate maps link: Invalid or missing Latitude/Longitude.")
                        else:
                            # Clear any previous map URL if the added object is not a location
                            st.session_state.map_url_to_display = None
                        # --- End Maps Link Generation ---

                        # Update default selections for relationship creation if needed
                        if len(st.session_state.nodes) >= 1: st.session_state.rel_source_sel = st.session_state.nodes[0]['data']['id']
                        if len(st.session_state.nodes) >= 2: st.session_state.rel_target_sel = st.session_state.nodes[1]['data']['id']
                        else: st.session_state.rel_target_sel = None # Reset target if only one node

                        st.rerun() # Rerun to update the graph and potentially show map link

                    # Catch specific stix2 validation errors
                    except InvalidValueError as ve: st.error(f"STIX Validation Error creating '{obj_args.get('name', obj_args.get('value', obj_id))}': {ve}")
                    except MissingPropertiesError as mpe: st.error(f"STIX Missing Properties Error: {mpe}")
                    # Catch general errors during object creation
                    except Exception as creation_e: st.error(f"Error creating STIX object '{obj_args.get('name', obj_args.get('value', obj_id))}': {creation_e}")

    # --- Create Relationship ---
    with st.expander("Create Relationship", expanded=False):
        # Filter eligible nodes (SDOs/SCOs, not relationships or markings)
        eligible_nodes = [o for o in st.session_state.objects if o.get('type') not in ['relationship', 'marking-definition']]
        # Create options dictionary for selectboxes {id: "Label (type)"}
        node_options = {o['id']: f"{o.get('name', o.get('value', o.get('id', 'ID Missing')))} ({o.get('type', 'Type Missing')})" for o in eligible_nodes}

        # Check if enough nodes exist to create a relationship
        if not eligible_nodes or len(eligible_nodes) < 2:
            st.info("Add at least two graph objects (excluding relationships/markings) first.")
        else:
            node_ids = list(node_options.keys())
            # Determine default indices for source and target selectboxes based on state or defaults
            default_source_index = 0; default_target_index = 0
            if st.session_state.get('rel_source_sel') in node_ids:
                default_source_index = node_ids.index(st.session_state.rel_source_sel)
            # Try to set a different default target
            if len(node_ids) > 1:
                 potential_target_index = 1 # Default to second node if first is source
                 if st.session_state.get('rel_target_sel') in node_ids:
                     potential_target_index = node_ids.index(st.session_state.rel_target_sel)
                 # Ensure target is different from source
                 if potential_target_index != default_source_index:
                     default_target_index = potential_target_index
                 elif default_source_index == 0: # If source is first, target is second
                     default_target_index = 1
                 else: # If source is not first, target can be first
                     default_target_index = 0
            # Ensure indices are within bounds
            default_source_index = max(0, min(default_source_index, len(node_ids) - 1))
            default_target_index = max(0, min(default_target_index, len(node_ids) - 1))

            # Callback to update session state when source/target selection changes
            def update_rel_sel(source_key, target_key):
                st.session_state.rel_source_sel = st.session_state[source_key]
                st.session_state.rel_target_sel = st.session_state[target_key]
                # Reset editing state when changing relationship selections
                st.session_state.editing_object_id = None
                st.session_state.editing_relationship_id = None

            # Source and Target selection widgets
            selected_source_id = st.selectbox("Source Object", options=node_ids, format_func=node_options.get, key="rel_source_select_widget", index=default_source_index, on_change=update_rel_sel, args=("rel_source_select_widget", "rel_target_select_widget"))
            selected_target_id = st.selectbox("Target Object", options=node_ids, format_func=node_options.get, key="rel_target_select_widget", index=default_target_index, on_change=update_rel_sel, args=("rel_source_select_widget", "rel_target_select_widget"))

            # Determine valid relationship types based on selected source and target types
            valid_rel_types_for_pair = []; rel_type_select_disabled = True; message = ""
            current_source_id = selected_source_id; current_target_id = selected_target_id
            if current_source_id and current_target_id:
                if current_source_id == current_target_id:
                    message = "Source and Target cannot be the same." # Prevent self-relationships via UI
                else:
                    source_type = get_object_type_from_id(current_source_id)
                    target_type = get_object_type_from_id(current_target_id)
                    if source_type and target_type:
                        key = (source_type, target_type)
                        # Look up valid types from the hardcoded dictionary
                        valid_rel_types_for_pair = HARDCODED_VALID_RELATIONSHIPS.get(key, [])
                        if valid_rel_types_for_pair:
                            rel_type_select_disabled = False # Enable selectbox if types exist
                        else:
                            message = f"No standard relationship types defined for {source_type} -> {target_type}."
                    else:
                        message = "Could not determine object types for relationship validation."

            # Display warning if no valid relationship types found (and source/target differ)
            if message and rel_type_select_disabled and current_source_id != current_target_id:
                st.warning(message)

            # Form for submitting the relationship creation
            with st.form("create_relationship_submit_form", clear_on_submit=True):
                # Relationship type selection (disabled if no valid types)
                selected_rel_type = st.selectbox("Relationship Type", options=valid_rel_types_for_pair, disabled=rel_type_select_disabled, key="rel_type_select_in_form", index=0 if valid_rel_types_for_pair else None)
                # Optional relationship description
                rel_description = st.text_area("Relationship Description (Optional)", key="rel_desc_input_in_form")
                # Submit button (disabled if no valid types)
                create_rel_button = st.form_submit_button("Create Relationship", disabled=rel_type_select_disabled)

                # Process relationship creation on submit
                if create_rel_button:
                    # Get values from state (widgets inside form update state on interaction)
                    form_source_id = st.session_state.rel_source_select_widget
                    form_target_id = st.session_state.rel_target_select_widget
                    form_rel_type = st.session_state.rel_type_select_in_form
                    form_rel_desc = st.session_state.rel_desc_input_in_form

                    # Validate selections before creating
                    if form_source_id and form_target_id and form_source_id != form_target_id and form_rel_type:
                        rel_id = f"relationship--{uuid.uuid4()}" # Generate relationship ID
                        # Construct the relationship dictionary
                        rel = {'type': 'relationship', 'id': rel_id, 'spec_version': '2.1',
                               'relationship_type': form_rel_type,
                               'source_ref': form_source_id, 'target_ref': form_target_id}
                        if form_rel_desc: rel['description'] = form_rel_desc # Add description if provided
                        # Add relationship object and edge to session state
                        st.session_state.objects.append(rel)
                        st.session_state.edges.append({'data': {'id': rel_id, 'source': form_source_id, 'target': form_target_id, 'label': form_rel_type}})
                        st.success(f"Created relationship '{form_rel_type}'")
                        st.rerun() # Update graph
                    else:
                         # Provide specific error messages
                         if not form_rel_type: st.error("Cannot create relationship: No valid type selected or available.")
                         elif form_source_id == form_target_id: st.error("Cannot create relationship: Source and Target cannot be the same.")
                         else: st.error("Cannot create relationship. Check Source, Target, and Type selections.")

    # --- Edit Object Form ---
    # Expander is open if an object is currently being edited
    with st.expander("Edit Selected Object", expanded=(st.session_state.editing_object_id is not None)):
        if st.session_state.editing_object_id:
            # Find the object to edit in the session state list
            object_to_edit = next((o for o in st.session_state.objects if o.get('id') == st.session_state.editing_object_id), None)
            if object_to_edit:
                edit_obj_type = object_to_edit.get('type', 'unknown')
                # Determine display label for the object being edited
                edit_label = object_to_edit.get('name', object_to_edit.get('value', st.session_state.editing_object_id)) # Use value for SCOs
                if edit_obj_type == 'x509-certificate':
                    edit_label = object_to_edit.get('serial_number', object_to_edit.get('subject', st.session_state.editing_object_id))
                elif edit_obj_type == 'note':
                     edit_label = object_to_edit.get('abstract', st.session_state.editing_object_id)
                elif edit_obj_type == 'malware-analysis':
                     edit_label = object_to_edit.get('product', st.session_state.editing_object_id)

                st.info(f"Editing: {edit_label} ({edit_obj_type})")
                # Container with specific styling for the edit form
                st.markdown('<div class="edit-form-container">', unsafe_allow_html=True)
                # Form for editing the object
                with st.form(f"edit_object_form_{st.session_state.editing_object_id}", clear_on_submit=False): # Keep values on submit for feedback
                    # Generate form fields pre-filled with existing object data
                    edit_form_data = generate_object_form_fields(edit_obj_type, obj_data=object_to_edit, key_prefix="edit")
                    # Submit button for the edit form
                    update_obj_submit = st.form_submit_button("Update Object")

                    # Process form submission for update
                    if update_obj_submit:
                        validation_passed = True; error_messages = []
                        # --- Re-apply Validation Rules for Edit ---
                        # (Same validation logic as in the Add form)
                        if edit_obj_type == 'domain-name' and not edit_form_data.get('domain_value'):
                            error_messages.append("Domain Name 'Value' is required."); validation_passed = False
                        if edit_obj_type == 'note':
                            if not edit_form_data.get('note_content'): error_messages.append("Note 'Content' is required."); validation_passed = False
                            if not edit_form_data.get('note_object_refs_str'): error_messages.append("Note 'Object Refs' are required."); validation_passed = False
                        if edit_obj_type == 'report':
                             if not edit_form_data.get('name'): error_messages.append("Report 'Name' is required."); validation_passed = False
                             if not edit_form_data.get('rep_report_types'): error_messages.append("Report 'Report Types' are required."); validation_passed = False
                             if not edit_form_data.get('published_date'): error_messages.append("Report 'Published Date' is required."); validation_passed = False
                             if not edit_form_data.get('rep_object_refs_str'): error_messages.append("Report 'Object Refs' are required."); validation_passed = False
                        if edit_obj_type == 'software' and not edit_form_data.get('name'):
                             error_messages.append("Software 'Name' is required."); validation_passed = False
                        if edit_obj_type == 'course-of-action' and not edit_form_data.get('name'):
                             error_messages.append("Course of Action 'Name' is required."); validation_passed = False
                        if edit_obj_type == 'malware-analysis':
                             if not edit_form_data.get('ma_product'): error_messages.append("Malware Analysis 'Product' is required."); validation_passed = False
                             if not edit_form_data.get('ma_av_result') and not edit_form_data.get('ma_analysis_sco_refs_str'): error_messages.append("Malware Analysis requires either 'AV Result' or 'Analysis SCO Refs'."); validation_passed = False
                        if edit_obj_type == 'indicator':
                              if not edit_form_data.get('ind_pattern_type'): error_messages.append("Indicator 'Pattern Type' is required."); validation_passed = False
                              if not edit_form_data.get('ind_pattern'): error_messages.append("Indicator 'Pattern' is required."); validation_passed = False
                              if not edit_form_data.get('valid_from_date'): error_messages.append("Indicator 'Valid From Date' is required."); validation_passed = False
                        if edit_obj_type == 'observed-data':
                              if not edit_form_data.get('first_observed_date') or not edit_form_data.get('last_observed_date') or not edit_form_data.get('obs_number_observed') or not edit_form_data.get('obs_object_refs_str'):
                                  error_messages.append("Observed Data requires 'First Observed', 'Last Observed', 'Number Observed', and 'Object Refs'."); validation_passed = False
                        if edit_obj_type == 'threat-actor' and not edit_form_data.get('ta_threat_actor_types'):
                              error_messages.append("Threat Actor 'Threat Actor Types' are required."); validation_passed = False
                        if edit_obj_type == 'malware':
                             if not edit_form_data.get('mal_is_family', False) and not edit_form_data.get('mal_malware_types'):
                                  error_messages.append("Malware 'Malware Types' are required when 'Is Family' is unchecked."); validation_passed = False
                             if edit_form_data.get('mal_is_family', False) and not edit_form_data.get('name'):
                                  error_messages.append("Malware 'Name' is required when 'Is Family' is checked."); validation_passed = False
                        # --- End Validation ---

                        # Display errors if validation failed
                        if not validation_passed:
                            for msg in error_messages: st.error(msg)

                        # Proceed with update if validation passed and form data exists
                        if validation_passed and edit_form_data:
                            try:
                                # Parse the edited form data into stix2 arguments
                                update_args = parse_form_data_to_stix_args(edit_form_data, edit_obj_type)
                                # Find the index of the object being edited
                                obj_index = next((i for i, o in enumerate(st.session_state.objects) if o.get('id') == st.session_state.editing_object_id), -1)

                                if obj_index != -1:
                                    # Get the original object and create a copy to update
                                    original_obj = st.session_state.objects[obj_index]; updated_obj = original_obj.copy()
                                    # Update the 'modified' timestamp
                                    updated_obj['modified'] = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ') # Use timezone.utc

                                    # Apply changes from the parsed form data (update_args)
                                    # This overwrites existing values or adds new ones based on the form
                                    for key, value in update_args.items():
                                        updated_obj[key] = value

                                    # Remove keys from the object that are NOT in the parsed form data
                                    # AND are not essential base fields (id, type, etc.).
                                    # This handles cases where optional fields were cleared in the form.
                                    base_fields = ['id', 'type', 'spec_version', 'created', 'modified']
                                    keys_to_remove = [k for k in updated_obj if k not in update_args and k not in base_fields]
                                    for k in keys_to_remove:
                                        del updated_obj[k]

                                    # --- Ensure 'type' is present before parsing ---
                                    # parse() requires 'type', make sure it wasn't accidentally removed.
                                    updated_obj['type'] = edit_obj_type

                                    # --- Validate the updated object dictionary using stix2.parse ---
                                    # This ensures the updated object still conforms to the STIX standard.
                                    temp_stix_obj = parse(updated_obj, allow_custom=True)
                                    # Serialize the validated object back to ensure consistency
                                    validated_obj_dict = json.loads(temp_stix_obj.serialize())

                                    # Replace the old object with the validated, updated object in session state
                                    st.session_state.objects[obj_index] = validated_obj_dict

                                    # --- Update node label in graph data if relevant field changed ---
                                    node_index = next((i for i, n in enumerate(st.session_state.nodes) if n['data']['id'] == st.session_state.editing_object_id), -1)
                                    if node_index != -1:
                                        # Determine the new label based on the updated object data
                                        new_label = validated_obj_dict.get('name', validated_obj_dict.get('value')) # Use value for SCOs
                                        if edit_obj_type == 'x509-certificate' and not new_label:
                                            new_label = validated_obj_dict.get('serial_number', validated_obj_dict.get('subject', st.session_state.editing_object_id))
                                        elif edit_obj_type == 'note' and not new_label:
                                             new_label = validated_obj_dict.get('abstract', st.session_state.editing_object_id)
                                        elif edit_obj_type == 'malware-analysis' and not new_label:
                                             new_label = validated_obj_dict.get('product', st.session_state.editing_object_id)
                                        elif not new_label:
                                            new_label = st.session_state.editing_object_id # Fallback to ID
                                        # Update the label in the nodes list
                                        st.session_state.nodes[node_index]['data']['label'] = new_label

                                    st.success(f"Updated object: {st.session_state.editing_object_id}")

                                    # --- Generate Maps Link AFTER successful submission ---
                                    if edit_obj_type == "location":
                                        lat = edit_form_data.get("loc_latitude")
                                        lon = edit_form_data.get("loc_longitude")
                                        maps_url = generate_maps_link(lat, lon)
                                        st.session_state.map_url_to_display = maps_url # Store URL
                                        if not maps_url:
                                            st.warning("Could not generate maps link: Invalid or missing Latitude/Longitude.")
                                    else:
                                         st.session_state.map_url_to_display = None # Clear if not location
                                    # --- End Maps Link Generation ---

                                    # Clear editing state after successful update
                                    # st.session_state.editing_object_id = None # Keep form open for review? Maybe clear on next action.
                                    st.rerun() # Rerun to reflect changes in graph/sidebar and show map link

                                else: st.error("Error: Could not find object in state to update.")
                            # Catch validation and other errors during update
                            except InvalidValueError as ve: st.error(f"STIX Validation Error updating object: {ve}")
                            except MissingPropertiesError as mpe: st.error(f"STIX Missing Properties Error: {mpe}")
                            except Exception as update_e: st.error(f"Error updating object: {update_e}")
                st.markdown('</div>', unsafe_allow_html=True) # Close the styled container
            else:
                # Handle case where the object ID in state is no longer valid
                st.warning("Selected object not found (it may have been deleted)."); st.session_state.editing_object_id = None
        else:
            # Message when no object is selected for editing
            st.info("Select a single node in the graph to edit its properties.")

    # --- Edit Relationship Form ---
    # Expander is open if a relationship is currently being edited
    with st.expander("Edit Selected Relationship", expanded=(st.session_state.editing_relationship_id is not None)):
        if st.session_state.editing_relationship_id:
            # Find the relationship object to edit
            rel_to_edit = next((o for o in st.session_state.objects if o.get('id') == st.session_state.editing_relationship_id), None)
            # Ensure it's actually a relationship object
            if rel_to_edit and rel_to_edit.get('type') == 'relationship':
                source_ref = rel_to_edit.get('source_ref'); target_ref = rel_to_edit.get('target_ref')
                current_rel_type = rel_to_edit.get('relationship_type'); current_desc = rel_to_edit.get('description', '')

                # Find the source and target objects to display labels and validate types
                source_obj = next((o for o in st.session_state.objects if o.get('id') == source_ref), None)
                target_obj = next((o for o in st.session_state.objects if o.get('id') == target_ref), None)

                if source_obj and target_obj:
                    # Create display labels for source and target
                    source_label = f"{source_obj.get('name', source_obj.get('value', source_ref))} ({source_obj.get('type')})"
                    target_label = f"{target_obj.get('name', target_obj.get('value', target_ref))} ({target_obj.get('type')})"
                    st.info(f"Editing Relationship: {source_label} -> {target_label}")

                    # Determine valid relationship types for this source/target pair
                    source_type = source_obj.get('type'); target_type = target_obj.get('type')
                    valid_rel_types = HARDCODED_VALID_RELATIONSHIPS.get((source_type, target_type), [])
                    # Ensure the current relationship type is in the list, even if not standard
                    if current_rel_type not in valid_rel_types: valid_rel_types.append(current_rel_type)
                    # Find the index of the current type for the selectbox default
                    rel_type_index = valid_rel_types.index(current_rel_type) if current_rel_type in valid_rel_types else 0

                    # Container with specific styling for the relationship edit form
                    st.markdown('<div class="edit-rel-form-container">', unsafe_allow_html=True)
                    # Form for editing the relationship
                    with st.form(f"edit_relationship_form_{st.session_state.editing_relationship_id}", clear_on_submit=False):
                        # Display source and target (disabled)
                        st.text_input("Source", value=source_label, disabled=True); st.text_input("Target", value=target_label, disabled=True)
                        # Selectbox for the relationship type
                        new_rel_type = st.selectbox("Relationship Type", options=valid_rel_types, index=rel_type_index, key=f"edit_rel_type_{st.session_state.editing_relationship_id}", disabled=not valid_rel_types)
                        # Text area for the description
                        new_desc = st.text_area("Description", value=current_desc, key=f"edit_rel_desc_{st.session_state.editing_relationship_id}")
                        # Submit button
                        update_rel_submit = st.form_submit_button("Update Relationship")

                        # Process relationship update on submit
                        if update_rel_submit:
                            try:
                                # Find the index of the relationship object and edge in session state
                                rel_obj_index = next((i for i, o in enumerate(st.session_state.objects) if o.get('id') == st.session_state.editing_relationship_id), -1)
                                edge_index = next((i for i, e in enumerate(st.session_state.edges) if e['data']['id'] == st.session_state.editing_relationship_id), -1)

                                if rel_obj_index != -1 and edge_index != -1:
                                    # Update the relationship object dictionary
                                    updated_rel_obj = st.session_state.objects[rel_obj_index].copy()
                                    updated_rel_obj['relationship_type'] = new_rel_type
                                    # Update or remove description based on input
                                    if new_desc: updated_rel_obj['description'] = new_desc
                                    elif 'description' in updated_rel_obj: del updated_rel_obj['description']
                                    # Update modified timestamp
                                    updated_rel_obj['modified'] = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
                                    st.session_state.objects[rel_obj_index] = updated_rel_obj

                                    # Update the corresponding edge label in the graph data
                                    st.session_state.edges[edge_index]['data']['label'] = new_rel_type
                                    st.success(f"Updated relationship: {st.session_state.editing_relationship_id}")
                                    # st.session_state.editing_relationship_id = None # Clear editing state
                                    st.rerun() # Update graph
                                else: st.error("Error: Could not find relationship object or edge in state.")
                            except Exception as update_e: st.error(f"Error updating relationship: {update_e}")
                    st.markdown('</div>', unsafe_allow_html=True) # Close styled container
                else:
                    # Handle case where source or target object not found (e.g., deleted)
                    st.warning("Could not find source or target object for the selected relationship."); st.session_state.editing_relationship_id = None
            else:
                # Handle case where selected element is not a relationship or not found
                st.warning("Selected element is not a relationship or not found."); st.session_state.editing_relationship_id = None
        else:
            # Message when no relationship is selected
            st.info("Select a single edge (relationship) in the graph to edit its properties.")

    # --- Remove Selected Element ---
    with st.expander("Remove Selected Elements", expanded=False):
        elements_to_remove_ids = []
        # Get the current selection from the graph (nodes and/or edges)
        current_selection = st.session_state.get('current_selection')
        if current_selection and isinstance(current_selection, dict):
            # Extract IDs from selected nodes and edges
            selected_nodes_data = current_selection.get("nodes", [])
            selected_edges_data = current_selection.get("edges", [])
            # Handle different formats cytoscape might return
            if selected_nodes_data:
                if selected_nodes_data and isinstance(selected_nodes_data[0], dict): elements_to_remove_ids.extend([node['id'] for node in selected_nodes_data])
                else: elements_to_remove_ids.extend(selected_nodes_data) # Assume list of IDs
            if selected_edges_data:
                if selected_edges_data and isinstance(selected_edges_data[0], dict): elements_to_remove_ids.extend([edge['id'] for edge in selected_edges_data])
                else: elements_to_remove_ids.extend(selected_edges_data) # Assume list of IDs

        # If elements are selected for removal
        if elements_to_remove_ids:
            st.write("Currently selected for removal:")
            # Display the first few selected elements for confirmation
            for elem_id in elements_to_remove_ids[:5]:
                 obj = next((o for o in st.session_state.objects if o.get('id') == elem_id), None); label = elem_id
                 if obj: # Format label for display
                     obj_type_display = obj.get('type', 'N/A').replace('-', ' ').title()
                     obj_name_display = obj.get('name', obj.get('value', elem_id))
                     if obj.get('type') == 'relationship': obj_name_display = f"{obj.get('source_ref', '?')} -> {obj.get('target_ref', '?')}"
                     label = f"{obj_type_display}: {obj_name_display}"
                 st.text(f"- {label}")
            if len(elements_to_remove_ids) > 5: st.text(f"... and {len(elements_to_remove_ids) - 5} more.")
            st.markdown("---")
            # Confirmation button
            if st.button(f"Confirm Removal of {len(elements_to_remove_ids)} Element(s)", key="remove_button_sidebar"):
                num_removed = len(elements_to_remove_ids); ids_being_removed = set(elements_to_remove_ids)
                # Call helper function to remove each element and connected relationships
                for elem_id in elements_to_remove_ids: remove_element(elem_id)
                st.success(f"Removed {num_removed} element(s).")
                # Clear selection and potentially editing state if removed element was being edited
                st.session_state.current_selection = None
                if st.session_state.editing_object_id in ids_being_removed: st.session_state.editing_object_id = None
                if st.session_state.editing_relationship_id in ids_being_removed: st.session_state.editing_relationship_id = None
                st.rerun() # Update graph
        else:
            # Message when no elements are selected
            st.info("Click elements in the graph to select them for removal.")

    # --- Export STIX bundle ---
    with st.expander("Export Bundle", expanded=False):
        # Button to trigger bundle generation and download
        if st.button("Generate & Download STIX 2.1 Bundle"):
            if not st.session_state.objects: st.warning("No objects to export.")
            else:
                try:
                    # Prepare objects for bundling (ensure spec_version is present)
                    bundle_objects_for_export = []
                    for obj in st.session_state.objects:
                         obj_copy = obj.copy()
                         if 'spec_version' not in obj_copy: obj_copy['spec_version'] = '2.1'
                         bundle_objects_for_export.append(obj_copy)
                    # Create the STIX Bundle object
                    bundle_to_export = Bundle(objects=bundle_objects_for_export, allow_custom=True)
                    # Serialize the bundle to a pretty-printed JSON string
                    output = bundle_to_export.serialize(pretty=True)
                    # Provide download button
                    st.download_button(label="Download Bundle JSON", data=output, file_name="stix_bundle.json", mime="application/json", key="download_bundle_button")
                except Exception as e: st.error(f"Error exporting bundle: {e}")

    # --- Display Raw Objects ---
    # Option to view the raw JSON of objects currently in state (for debugging)
    with st.expander("Show Raw STIX Objects", expanded=False):
         if st.session_state.objects: st.json(st.session_state.objects)
         else: st.info("No objects currently in session state.")

# --- Main Area Content ---

# --- Display Map Link (if generated from last add/edit submission) ---
if st.session_state.map_url_to_display:
    # Display the link using Markdown for styling
    st.markdown(f'<div class="maps-link-container"> [View Location on Google Maps]({st.session_state.map_url_to_display})</div>', unsafe_allow_html=True)
    st.session_state.map_url_to_display = None # Clear the state after displaying once

# --- Graph Section ---
# Header with title and fullscreen toggle button
header_cols = st.columns([0.85, 0.15])
with header_cols[0]: st.markdown("#### Graph View", unsafe_allow_html=True)
with header_cols[1]:
    fullscreen_btn_label = "Exit Full Screen" if st.session_state.fullscreen_mode else "Enter Full Screen"
    if st.button(fullscreen_btn_label, key="fullscreen_toggle"):
        st.session_state.fullscreen_mode = not st.session_state.fullscreen_mode
        st.rerun() # Rerun to apply fullscreen change

# Adjust graph height based on fullscreen mode
graph_height = "1200px" if st.session_state.fullscreen_mode else "800px"

# --- Prepare Graph Elements and Stylesheet ---
# Filter nodes and edges to ensure they are valid dictionaries with required keys
valid_nodes = [n for n in st.session_state.nodes if isinstance(n, dict) and 'data' in n and 'id' in n['data']]
valid_edges = [e for e in st.session_state.edges if isinstance(e, dict) and 'data' in e and 'id' in e['data'] and 'source' in e['data'] and 'target' in e['data']]
# Further filter edges to ensure source and target nodes exist
valid_node_ids = {n['data']['id'] for n in valid_nodes}
valid_edges = [e for e in valid_edges if e['data']['source'] in valid_node_ids and e['data']['target'] in valid_node_ids]
# Combine valid nodes and edges for Cytoscape
elements = valid_nodes + valid_edges

# Define Cytoscape stylesheet (fixed light theme)
stylesheet = [
    # Default node style
    { 'selector': 'node', 'style': {
        'label': 'data(label)', 'width': 60, 'height': 60,
        'background-fit': 'contain', 'background-color': '#ddd', # Default background
        'border-width': 1, 'border-color': '#555',
        'font-size': '9px', 'text-valign': 'bottom', 'text-halign': 'center',
        'text-margin-y': 5, 'text-wrap': 'wrap', 'text-max-width': 80, 'color': '#0e1117'
    }},
    # Default edge style
    { 'selector': 'edge', 'style': {
        'label': 'data(label)', 'width': 2, 'line-color': '#67a3e0',
        'target-arrow-color': '#67a3e0', 'target-arrow-shape': 'triangle',
        'curve-style': 'bezier', 'font-size': '9px', 'color': '#555',
        'text-rotation': 'autorotate', 'text-background-color': '#ffffff',
        'text-background-opacity': 0, 'text-background-padding': '2px' # Transparent label background
    }},
    # Style for selected elements
    { 'selector': ':selected', 'style': {
        'border-width': 4, 'border-color': '#e74c3c', 'line-color': '#e74c3c',
        'target-arrow-color': '#e74c3c', 'background-color': '#f7cac9', 'z-index': 9999
    }}
]
# Dynamically add styles for node icons based on types present in the graph
types_in_graph = set(get_object_type_from_id(n['data']['id']) for n in valid_nodes)
for t in types_in_graph:
    if t: # Ensure type is not None
        data_uri = get_icon_data_uri(t) # Get cached icon data URI
        if data_uri:
            # Add style rule for nodes of this type to use the icon
            stylesheet.append({
                'selector': f'node[id ^= "{t}--"]', # Select nodes whose ID starts with "type--"
                'style': { 'background-image': data_uri, 'background-fit': 'contain',
                           'background-color': 'transparent', 'background-opacity': 0 } # Make default background transparent
            })

# --- Display Cytoscape Graph ---
if not elements:
    st.info("Load a STIX bundle or add objects using the sidebar to view the graph.")
    selected = None # No selection if no elements
else:
    # Render the Cytoscape graph component
    selected = cytoscape(
        elements=elements,
        stylesheet=stylesheet,
        layout={ 'name': 'cose', 'idealEdgeLength': 150, 'nodeOverlap': 20, 'padding': 30, 'animate': False }, # COSE layout
        width="100%",
        height=graph_height,
        selection_type='multiple', # Allow selecting multiple elements
        key="stix_graph_final" # Unique key for the component
    )

# --- Process Graph Selection Update ---
# This logic runs on every interaction to update the editing state based on graph selection
current_selection_in_state = st.session_state.get('current_selection')
new_editing_object_id = None; new_editing_relationship_id = None; rerun_needed_for_edit_state_change = False

# Check if the selection from the graph component has changed
if selected is not None and selected != current_selection_in_state:
    st.session_state.current_selection = selected # Update selection in state
    selected_nodes = selected.get("nodes", []); selected_edges = selected.get("edges", [])

    # Logic to determine if an object or relationship should be put into editing mode
    if len(selected_nodes) == 1 and not selected_edges: # Single node selected
        # Handle different formats cytoscape might return for selection
        node_id = selected_nodes[0]['id'] if isinstance(selected_nodes[0], dict) else selected_nodes[0]
        # If the selected node is different from the one currently being edited
        if node_id != st.session_state.editing_object_id:
            new_editing_object_id = node_id; new_editing_relationship_id = None # Set new edit target
            rerun_needed_for_edit_state_change = True
    elif len(selected_edges) == 1 and not selected_nodes: # Single edge selected
        edge_id = selected_edges[0]['id'] if isinstance(selected_edges[0], dict) else selected_edges[0]
        # If the selected edge is different from the one currently being edited
        if edge_id != st.session_state.editing_relationship_id:
            new_editing_relationship_id = edge_id; new_editing_object_id = None # Set new edit target
            rerun_needed_for_edit_state_change = True
    # If multiple elements are selected or selection cleared, exit editing mode
    elif st.session_state.editing_object_id is not None or st.session_state.editing_relationship_id is not None:
        new_editing_object_id = None; new_editing_relationship_id = None # Clear edit target
        rerun_needed_for_edit_state_change = True

    # Rerun the script if the editing state changed OR if the selection changed (not in fullscreen)
    if rerun_needed_for_edit_state_change or (not st.session_state.fullscreen_mode and selected != current_selection_in_state):
        st.session_state.editing_object_id = new_editing_object_id
        st.session_state.editing_relationship_id = new_editing_relationship_id
        st.rerun()

# Handle case where selection becomes None (cleared)
elif selected is None and current_selection_in_state is not None:
     st.session_state.current_selection = None # Update state
     # If exiting a selection while something was being edited, clear editing state
     if st.session_state.editing_object_id is not None or st.session_state.editing_relationship_id is not None:
         st.session_state.editing_object_id = None; st.session_state.editing_relationship_id = None
         st.rerun() # Rerun to close edit forms
     # Rerun even if not editing, to update selection display (unless in fullscreen)
     elif not st.session_state.fullscreen_mode:
         st.rerun()

# --- Display Selected Object Details (Below Graph) ---
# This section shows details of the currently selected single node or edge.
if st.session_state.current_selection and isinstance(st.session_state.current_selection, dict):
    selected_nodes = st.session_state.current_selection.get("nodes", [])
    selected_edges = st.session_state.current_selection.get("edges", [])

    # Display details only if exactly one element (node OR edge) is selected
    if (len(selected_nodes) == 1 and not selected_edges) or (len(selected_edges) == 1 and not selected_nodes):
        selected_id = None
        if selected_nodes:
            selected_id = selected_nodes[0]['id'] if isinstance(selected_nodes[0], dict) else selected_nodes[0]
        elif selected_edges:
            selected_id = selected_edges[0]['id'] if isinstance(selected_edges[0], dict) else selected_edges[0]

        if selected_id:
            selected_obj_data = next((o for o in st.session_state.objects if o.get('id') == selected_id), None)
            if selected_obj_data:
                st.subheader("Selected Element Details")
                # Use Markdown with custom class for styling the details box
                st.markdown('<div class="selected-node-main">', unsafe_allow_html=True)
                for key, value in selected_obj_data.items():
                    # Format key for display (replace underscores, title case)
                    key_display = key.replace('_', ' ').title()
                    # Format value for display (handle lists, dicts, etc.)
                    value_display = value
                    if isinstance(value, list):
                        value_display = ", ".join(map(str, value)) if value else " " # Join lists, handle empty
                    elif isinstance(value, dict):
                        # Pretty print dictionaries
                        value_display = f"<pre style='white-space: pre-wrap; word-wrap: break-word; margin: 0;'>{json.dumps(value, indent=2)}</pre>"
                        st.markdown(f'<span class="selected-node-label-main">{key_display}:</span> {value_display}', unsafe_allow_html=True)
                        continue # Skip default printing for dicts

                    # Display key-value pair using Markdown spans for styling
                    st.markdown(f'<span class="selected-node-label-main">{key_display}:</span> {value_display}', unsafe_allow_html=True)

                st.markdown('</div>', unsafe_allow_html=True) # Close the styled container
            else:
                st.warning(f"Details not found for selected element ID: {selected_id}")
    elif len(selected_nodes) > 1 or len(selected_edges) > 1 or (selected_nodes and selected_edges):
        # Message if multiple elements are selected
        st.info(f"Multiple elements selected ({len(selected_nodes)} nodes, {len(selected_edges)} edges). Select a single element to view details.")
